"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-responsive";
exports.ids = ["vendor-chunks/react-responsive"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-responsive/dist/react-responsive.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-responsive/dist/react-responsive.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n    else {}\n})(void 0, (__WEBPACK_EXTERNAL_MODULE_react__)=>{\n    return /******/ (()=>{\n        /******/ var __webpack_modules__ = {\n            /***/ \"./node_modules/css-mediaquery/index.js\": /*!**********************************************!*\\\n  !*** ./node_modules/css-mediaquery/index.js ***!\n  \\**********************************************/ /***/ (__unused_webpack_module, exports1)=>{\n                \"use strict\";\n                /*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/ exports1.match = matchQuery;\n                exports1.parse = parseQuery;\n                // -----------------------------------------------------------------------------\n                var RE_MEDIA_QUERY = /(?:(only|not)?\\s*([^\\s\\(\\)]+)(?:\\s*and)?\\s*)?(.+)?/i, RE_MQ_EXPRESSION = /\\(\\s*([^\\s\\:\\)]+)\\s*(?:\\:\\s*([^\\s\\)]+))?\\s*\\)/, RE_MQ_FEATURE = /^(?:(min|max)-)?(.+)/, RE_LENGTH_UNIT = /(em|rem|px|cm|mm|in|pt|pc)?$/, RE_RESOLUTION_UNIT = /(dpi|dpcm|dppx)?$/;\n                function matchQuery(mediaQuery, values) {\n                    return parseQuery(mediaQuery).some(function(query) {\n                        var inverse = query.inverse;\n                        // Either the parsed or specified `type` is \"all\", or the types must be\n                        // equal for a match.\n                        var typeMatch = query.type === \"all\" || values.type === query.type;\n                        // Quit early when `type` doesn't match, but take \"not\" into account.\n                        if (typeMatch && inverse || !(typeMatch || inverse)) {\n                            return false;\n                        }\n                        var expressionsMatch = query.expressions.every(function(expression) {\n                            var feature = expression.feature, modifier = expression.modifier, expValue = expression.value, value = values[feature];\n                            // Missing or falsy values don't match.\n                            if (!value) {\n                                return false;\n                            }\n                            switch(feature){\n                                case \"orientation\":\n                                case \"scan\":\n                                    return value.toLowerCase() === expValue.toLowerCase();\n                                case \"width\":\n                                case \"height\":\n                                case \"device-width\":\n                                case \"device-height\":\n                                    expValue = toPx(expValue);\n                                    value = toPx(value);\n                                    break;\n                                case \"resolution\":\n                                    expValue = toDpi(expValue);\n                                    value = toDpi(value);\n                                    break;\n                                case \"aspect-ratio\":\n                                case \"device-aspect-ratio\":\n                                case /* Deprecated */ \"device-pixel-ratio\":\n                                    expValue = toDecimal(expValue);\n                                    value = toDecimal(value);\n                                    break;\n                                case \"grid\":\n                                case \"color\":\n                                case \"color-index\":\n                                case \"monochrome\":\n                                    expValue = parseInt(expValue, 10) || 1;\n                                    value = parseInt(value, 10) || 0;\n                                    break;\n                            }\n                            switch(modifier){\n                                case \"min\":\n                                    return value >= expValue;\n                                case \"max\":\n                                    return value <= expValue;\n                                default:\n                                    return value === expValue;\n                            }\n                        });\n                        return expressionsMatch && !inverse || !expressionsMatch && inverse;\n                    });\n                }\n                function parseQuery(mediaQuery) {\n                    return mediaQuery.split(\",\").map(function(query) {\n                        query = query.trim();\n                        var captures = query.match(RE_MEDIA_QUERY), modifier = captures[1], type = captures[2], expressions = captures[3] || \"\", parsed = {};\n                        parsed.inverse = !!modifier && modifier.toLowerCase() === \"not\";\n                        parsed.type = type ? type.toLowerCase() : \"all\";\n                        // Split expressions into a list.\n                        expressions = expressions.match(/\\([^\\)]+\\)/g) || [];\n                        parsed.expressions = expressions.map(function(expression) {\n                            var captures = expression.match(RE_MQ_EXPRESSION), feature = captures[1].toLowerCase().match(RE_MQ_FEATURE);\n                            return {\n                                modifier: feature[1],\n                                feature: feature[2],\n                                value: captures[2]\n                            };\n                        });\n                        return parsed;\n                    });\n                }\n                // -- Utilities ----------------------------------------------------------------\n                function toDecimal(ratio) {\n                    var decimal = Number(ratio), numbers;\n                    if (!decimal) {\n                        numbers = ratio.match(/^(\\d+)\\s*\\/\\s*(\\d+)$/);\n                        decimal = numbers[1] / numbers[2];\n                    }\n                    return decimal;\n                }\n                function toDpi(resolution) {\n                    var value = parseFloat(resolution), units = String(resolution).match(RE_RESOLUTION_UNIT)[1];\n                    switch(units){\n                        case \"dpcm\":\n                            return value / 2.54;\n                        case \"dppx\":\n                            return value * 96;\n                        default:\n                            return value;\n                    }\n                }\n                function toPx(length) {\n                    var value = parseFloat(length), units = String(length).match(RE_LENGTH_UNIT)[1];\n                    switch(units){\n                        case \"em\":\n                            return value * 16;\n                        case \"rem\":\n                            return value * 16;\n                        case \"cm\":\n                            return value * 96 / 2.54;\n                        case \"mm\":\n                            return value * 96 / 2.54 / 10;\n                        case \"in\":\n                            return value * 96;\n                        case \"pt\":\n                            return value * 72;\n                        case \"pc\":\n                            return value * 72 / 12;\n                        default:\n                            return value;\n                    }\n                }\n            /***/ },\n            /***/ \"./node_modules/hyphenate-style-name/index.js\": /*!****************************************************!*\\\n  !*** ./node_modules/hyphenate-style-name/index.js ***!\n  \\****************************************************/ /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_8002__)=>{\n                \"use strict\";\n                __nested_webpack_require_8002__.r(__nested_webpack_exports__);\n                /* harmony export */ __nested_webpack_require_8002__.d(__nested_webpack_exports__, {\n                    /* harmony export */ \"default\": ()=>__WEBPACK_DEFAULT_EXPORT__\n                });\n                /* eslint-disable no-var, prefer-template */ var uppercasePattern = /[A-Z]/g;\n                var msPattern = /^ms-/;\n                var cache = {};\n                function toHyphenLower(match) {\n                    return \"-\" + match.toLowerCase();\n                }\n                function hyphenateStyleName(name) {\n                    if (cache.hasOwnProperty(name)) {\n                        return cache[name];\n                    }\n                    var hName = name.replace(uppercasePattern, toHyphenLower);\n                    return cache[name] = msPattern.test(hName) ? \"-\" + hName : hName;\n                }\n                /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = hyphenateStyleName;\n            /***/ },\n            /***/ \"./node_modules/matchmediaquery/index.js\": /*!***********************************************!*\\\n  !*** ./node_modules/matchmediaquery/index.js ***!\n  \\***********************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_9324__)=>{\n                \"use strict\";\n                var staticMatch = __nested_webpack_require_9324__(/*! css-mediaquery */ \"./node_modules/css-mediaquery/index.js\").match;\n                var dynamicMatch =  false ? 0 : null;\n                // our fake MediaQueryList\n                function Mql(query, values, forceStatic) {\n                    var self = this;\n                    if (dynamicMatch && !forceStatic) {\n                        var mql = dynamicMatch.call(window, query);\n                        this.matches = mql.matches;\n                        this.media = mql.media;\n                        // TODO: is there a time it makes sense to remove this listener?\n                        mql.addListener(update);\n                    } else {\n                        this.matches = staticMatch(query, values);\n                        this.media = query;\n                    }\n                    this.addListener = addListener;\n                    this.removeListener = removeListener;\n                    this.dispose = dispose;\n                    function addListener(listener) {\n                        if (mql) {\n                            mql.addListener(listener);\n                        }\n                    }\n                    function removeListener(listener) {\n                        if (mql) {\n                            mql.removeListener(listener);\n                        }\n                    }\n                    // update ourselves!\n                    function update(evt) {\n                        self.matches = evt.matches;\n                        self.media = evt.media;\n                    }\n                    function dispose() {\n                        if (mql) {\n                            mql.removeListener(update);\n                        }\n                    }\n                }\n                function matchMedia(query, values, forceStatic) {\n                    return new Mql(query, values, forceStatic);\n                }\n                module1.exports = matchMedia;\n            /***/ },\n            /***/ \"./node_modules/object-assign/index.js\": /*!*********************************************!*\\\n  !*** ./node_modules/object-assign/index.js ***!\n  \\*********************************************/ /***/ (module1)=>{\n                \"use strict\";\n                /*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/ /* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n                var hasOwnProperty = Object.prototype.hasOwnProperty;\n                var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n                function toObject(val) {\n                    if (val === null || val === undefined) {\n                        throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n                    }\n                    return Object(val);\n                }\n                function shouldUseNative() {\n                    try {\n                        if (!Object.assign) {\n                            return false;\n                        }\n                        // Detect buggy property enumeration order in older V8 versions.\n                        // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n                        var test1 = new String(\"abc\"); // eslint-disable-line no-new-wrappers\n                        test1[5] = \"de\";\n                        if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n                            return false;\n                        }\n                        // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                        var test2 = {};\n                        for(var i = 0; i < 10; i++){\n                            test2[\"_\" + String.fromCharCode(i)] = i;\n                        }\n                        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {\n                            return test2[n];\n                        });\n                        if (order2.join(\"\") !== \"0123456789\") {\n                            return false;\n                        }\n                        // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                        var test3 = {};\n                        \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n                            test3[letter] = letter;\n                        });\n                        if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n                            return false;\n                        }\n                        return true;\n                    } catch (err) {\n                        // We don't expect any of the above to throw, but better to be safe.\n                        return false;\n                    }\n                }\n                module1.exports = shouldUseNative() ? Object.assign : function(target, source) {\n                    var from;\n                    var to = toObject(target);\n                    var symbols;\n                    for(var s = 1; s < arguments.length; s++){\n                        from = Object(arguments[s]);\n                        for(var key in from){\n                            if (hasOwnProperty.call(from, key)) {\n                                to[key] = from[key];\n                            }\n                        }\n                        if (getOwnPropertySymbols) {\n                            symbols = getOwnPropertySymbols(from);\n                            for(var i = 0; i < symbols.length; i++){\n                                if (propIsEnumerable.call(from, symbols[i])) {\n                                    to[symbols[i]] = from[symbols[i]];\n                                }\n                            }\n                        }\n                    }\n                    return to;\n                };\n            /***/ },\n            /***/ \"./node_modules/prop-types/checkPropTypes.js\": /*!***************************************************!*\\\n  !*** ./node_modules/prop-types/checkPropTypes.js ***!\n  \\***************************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_15510__)=>{\n                \"use strict\";\n                /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var printWarning = function() {};\n                if (true) {\n                    var ReactPropTypesSecret = __nested_webpack_require_15510__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n                    var loggedTypeFailures = {};\n                    var has = __nested_webpack_require_15510__(/*! ./lib/has */ \"./node_modules/prop-types/lib/has.js\");\n                    printWarning = function(text) {\n                        var message = \"Warning: \" + text;\n                        if (typeof console !== \"undefined\") {\n                            console.error(message);\n                        }\n                        try {\n                            // --- Welcome to debugging React ---\n                            // This error was thrown as a convenience so that you can use this stack\n                            // to find the callsite that caused this warning to fire.\n                            throw new Error(message);\n                        } catch (x) {}\n                    };\n                }\n                /**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n                    if (true) {\n                        for(var typeSpecName in typeSpecs){\n                            if (has(typeSpecs, typeSpecName)) {\n                                var error;\n                                // Prop type validation may throw. In case they do, we don't want to\n                                // fail the render phase where it didn't fail before. So we log it.\n                                // After these have been cleaned up, we'll let them throw.\n                                try {\n                                    // This is intentionally an invariant that gets caught. It's the same\n                                    // behavior as without this statement except with a better message.\n                                    if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                        var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                        err.name = \"Invariant Violation\";\n                                        throw err;\n                                    }\n                                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n                                } catch (ex) {\n                                    error = ex;\n                                }\n                                if (error && !(error instanceof Error)) {\n                                    printWarning((componentName || \"React class\") + \": type specification of \" + location + \" `\" + typeSpecName + \"` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a \" + typeof error + \". \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\");\n                                }\n                                if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n                                    // Only monitor this failure once because there tends to be a lot of the\n                                    // same error.\n                                    loggedTypeFailures[error.message] = true;\n                                    var stack = getStack ? getStack() : \"\";\n                                    printWarning(\"Failed \" + location + \" type: \" + error.message + (stack != null ? stack : \"\"));\n                                }\n                            }\n                        }\n                    }\n                }\n                /**\n * Resets warning cache when testing.\n *\n * @private\n */ checkPropTypes.resetWarningCache = function() {\n                    if (true) {\n                        loggedTypeFailures = {};\n                    }\n                };\n                module1.exports = checkPropTypes;\n            /***/ },\n            /***/ \"./node_modules/prop-types/factoryWithTypeCheckers.js\": /*!************************************************************!*\\\n  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!\n  \\************************************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_20867__)=>{\n                \"use strict\";\n                /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var ReactIs = __nested_webpack_require_20867__(/*! react-is */ \"./node_modules/react-is/index.js\");\n                var assign = __nested_webpack_require_20867__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n                var ReactPropTypesSecret = __nested_webpack_require_20867__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n                var has = __nested_webpack_require_20867__(/*! ./lib/has */ \"./node_modules/prop-types/lib/has.js\");\n                var checkPropTypes = __nested_webpack_require_20867__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n                var printWarning = function() {};\n                if (true) {\n                    printWarning = function(text) {\n                        var message = \"Warning: \" + text;\n                        if (typeof console !== \"undefined\") {\n                            console.error(message);\n                        }\n                        try {\n                            // --- Welcome to debugging React ---\n                            // This error was thrown as a convenience so that you can use this stack\n                            // to find the callsite that caused this warning to fire.\n                            throw new Error(message);\n                        } catch (x) {}\n                    };\n                }\n                function emptyFunctionThatReturnsNull() {\n                    return null;\n                }\n                module1.exports = function(isValidElement, throwOnDirectAccess) {\n                    /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n                    var FAUX_ITERATOR_SYMBOL = \"@@iterator\"; // Before Symbol spec.\n                    /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */ function getIteratorFn(maybeIterable) {\n                        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n                        if (typeof iteratorFn === \"function\") {\n                            return iteratorFn;\n                        }\n                    }\n                    /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */ var ANONYMOUS = \"<<anonymous>>\";\n                    // Important!\n                    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n                    var ReactPropTypes = {\n                        array: createPrimitiveTypeChecker(\"array\"),\n                        bigint: createPrimitiveTypeChecker(\"bigint\"),\n                        bool: createPrimitiveTypeChecker(\"boolean\"),\n                        func: createPrimitiveTypeChecker(\"function\"),\n                        number: createPrimitiveTypeChecker(\"number\"),\n                        object: createPrimitiveTypeChecker(\"object\"),\n                        string: createPrimitiveTypeChecker(\"string\"),\n                        symbol: createPrimitiveTypeChecker(\"symbol\"),\n                        any: createAnyTypeChecker(),\n                        arrayOf: createArrayOfTypeChecker,\n                        element: createElementTypeChecker(),\n                        elementType: createElementTypeTypeChecker(),\n                        instanceOf: createInstanceTypeChecker,\n                        node: createNodeChecker(),\n                        objectOf: createObjectOfTypeChecker,\n                        oneOf: createEnumTypeChecker,\n                        oneOfType: createUnionTypeChecker,\n                        shape: createShapeTypeChecker,\n                        exact: createStrictShapeTypeChecker\n                    };\n                    /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */ /*eslint-disable no-self-compare*/ function is(x, y) {\n                        // SameValue algorithm\n                        if (x === y) {\n                            // Steps 1-5, 7-10\n                            // Steps 6.b-6.e: +0 != -0\n                            return x !== 0 || 1 / x === 1 / y;\n                        } else {\n                            // Step 6.a: NaN == NaN\n                            return x !== x && y !== y;\n                        }\n                    }\n                    /*eslint-enable no-self-compare*/ /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */ function PropTypeError(message, data) {\n                        this.message = message;\n                        this.data = data && typeof data === \"object\" ? data : {};\n                        this.stack = \"\";\n                    }\n                    // Make `instanceof Error` still work for returned errors.\n                    PropTypeError.prototype = Error.prototype;\n                    function createChainableTypeChecker(validate) {\n                        if (true) {\n                            var manualPropTypeCallCache = {};\n                            var manualPropTypeWarningCount = 0;\n                        }\n                        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n                            componentName = componentName || ANONYMOUS;\n                            propFullName = propFullName || propName;\n                            if (secret !== ReactPropTypesSecret) {\n                                if (throwOnDirectAccess) {\n                                    // New behavior only for users of `prop-types` package\n                                    var err = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use `PropTypes.checkPropTypes()` to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n                                    err.name = \"Invariant Violation\";\n                                    throw err;\n                                } else if ( true && typeof console !== \"undefined\") {\n                                    // Old behavior for people using React.PropTypes\n                                    var cacheKey = componentName + \":\" + propName;\n                                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors\n                                    manualPropTypeWarningCount < 3) {\n                                        printWarning(\"You are manually calling a React.PropTypes validation \" + \"function for the `\" + propFullName + \"` prop on `\" + componentName + \"`. This is deprecated \" + \"and will throw in the standalone `prop-types` package. \" + \"You may be seeing this warning due to a third-party PropTypes \" + \"library. See https://fb.me/react-warning-dont-call-proptypes \" + \"for details.\");\n                                        manualPropTypeCallCache[cacheKey] = true;\n                                        manualPropTypeWarningCount++;\n                                    }\n                                }\n                            }\n                            if (props[propName] == null) {\n                                if (isRequired) {\n                                    if (props[propName] === null) {\n                                        return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n                                    }\n                                    return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n                                }\n                                return null;\n                            } else {\n                                return validate(props, propName, componentName, location, propFullName);\n                            }\n                        }\n                        var chainedCheckType = checkType.bind(null, false);\n                        chainedCheckType.isRequired = checkType.bind(null, true);\n                        return chainedCheckType;\n                    }\n                    function createPrimitiveTypeChecker(expectedType) {\n                        function validate(props, propName, componentName, location, propFullName, secret) {\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== expectedType) {\n                                // `propValue` being instance of, say, date/regexp, pass the 'object'\n                                // check, but we can offer a more precise error message here rather than\n                                // 'of type `object`'.\n                                var preciseType = getPreciseType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + preciseType + \"` supplied to `\" + componentName + \"`, expected \") + (\"`\" + expectedType + \"`.\"), {\n                                    expectedType: expectedType\n                                });\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createAnyTypeChecker() {\n                        return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n                    }\n                    function createArrayOfTypeChecker(typeChecker) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (typeof typeChecker !== \"function\") {\n                                return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside arrayOf.\");\n                            }\n                            var propValue = props[propName];\n                            if (!Array.isArray(propValue)) {\n                                var propType = getPropType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\"));\n                            }\n                            for(var i = 0; i < propValue.length; i++){\n                                var error = typeChecker(propValue, i, componentName, location, propFullName + \"[\" + i + \"]\", ReactPropTypesSecret);\n                                if (error instanceof Error) {\n                                    return error;\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createElementTypeChecker() {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            if (!isValidElement(propValue)) {\n                                var propType = getPropType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createElementTypeTypeChecker() {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            if (!ReactIs.isValidElementType(propValue)) {\n                                var propType = getPropType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement type.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createInstanceTypeChecker(expectedClass) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (!(props[propName] instanceof expectedClass)) {\n                                var expectedClassName = expectedClass.name || ANONYMOUS;\n                                var actualClassName = getClassName(props[propName]);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + actualClassName + \"` supplied to `\" + componentName + \"`, expected \") + (\"instance of `\" + expectedClassName + \"`.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createEnumTypeChecker(expectedValues) {\n                        if (!Array.isArray(expectedValues)) {\n                            if (true) {\n                                if (arguments.length > 1) {\n                                    printWarning(\"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. \" + \"A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\");\n                                } else {\n                                    printWarning(\"Invalid argument supplied to oneOf, expected an array.\");\n                                }\n                            }\n                            return emptyFunctionThatReturnsNull;\n                        }\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            for(var i = 0; i < expectedValues.length; i++){\n                                if (is(propValue, expectedValues[i])) {\n                                    return null;\n                                }\n                            }\n                            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n                                var type = getPreciseType(value);\n                                if (type === \"symbol\") {\n                                    return String(value);\n                                }\n                                return value;\n                            });\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of value `\" + String(propValue) + \"` \" + (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\"));\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createObjectOfTypeChecker(typeChecker) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (typeof typeChecker !== \"function\") {\n                                return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside objectOf.\");\n                            }\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== \"object\") {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\"));\n                            }\n                            for(var key in propValue){\n                                if (has(propValue, key)) {\n                                    var error = typeChecker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                    if (error instanceof Error) {\n                                        return error;\n                                    }\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createUnionTypeChecker(arrayOfTypeCheckers) {\n                        if (!Array.isArray(arrayOfTypeCheckers)) {\n                             true ? printWarning(\"Invalid argument supplied to oneOfType, expected an instance of array.\") : 0;\n                            return emptyFunctionThatReturnsNull;\n                        }\n                        for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                            var checker = arrayOfTypeCheckers[i];\n                            if (typeof checker !== \"function\") {\n                                printWarning(\"Invalid argument supplied to oneOfType. Expected an array of check functions, but \" + \"received \" + getPostfixForTypeWarning(checker) + \" at index \" + i + \".\");\n                                return emptyFunctionThatReturnsNull;\n                            }\n                        }\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var expectedTypes = [];\n                            for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                                var checker = arrayOfTypeCheckers[i];\n                                var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n                                if (checkerResult == null) {\n                                    return null;\n                                }\n                                if (checkerResult.data && has(checkerResult.data, \"expectedType\")) {\n                                    expectedTypes.push(checkerResult.data.expectedType);\n                                }\n                            }\n                            var expectedTypesMessage = expectedTypes.length > 0 ? \", expected one of type [\" + expectedTypes.join(\", \") + \"]\" : \"\";\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`\" + expectedTypesMessage + \".\"));\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createNodeChecker() {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (!isNode(props[propName])) {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`, expected a ReactNode.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function invalidValidatorError(componentName, location, propFullName, key, type) {\n                        return new PropTypeError((componentName || \"React class\") + \": \" + location + \" type `\" + propFullName + \".\" + key + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + type + \"`.\");\n                    }\n                    function createShapeTypeChecker(shapeTypes) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== \"object\") {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                            }\n                            for(var key in shapeTypes){\n                                var checker = shapeTypes[key];\n                                if (typeof checker !== \"function\") {\n                                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n                                }\n                                var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                if (error) {\n                                    return error;\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createStrictShapeTypeChecker(shapeTypes) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== \"object\") {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                            }\n                            // We need to check all keys in case some are required but missing from props.\n                            var allKeys = assign({}, props[propName], shapeTypes);\n                            for(var key in allKeys){\n                                var checker = shapeTypes[key];\n                                if (has(shapeTypes, key) && typeof checker !== \"function\") {\n                                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n                                }\n                                if (!checker) {\n                                    return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` key `\" + key + \"` supplied to `\" + componentName + \"`.\" + \"\\nBad object: \" + JSON.stringify(props[propName], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(shapeTypes), null, \"  \"));\n                                }\n                                var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                if (error) {\n                                    return error;\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function isNode(propValue) {\n                        switch(typeof propValue){\n                            case \"number\":\n                            case \"string\":\n                            case \"undefined\":\n                                return true;\n                            case \"boolean\":\n                                return !propValue;\n                            case \"object\":\n                                if (Array.isArray(propValue)) {\n                                    return propValue.every(isNode);\n                                }\n                                if (propValue === null || isValidElement(propValue)) {\n                                    return true;\n                                }\n                                var iteratorFn = getIteratorFn(propValue);\n                                if (iteratorFn) {\n                                    var iterator = iteratorFn.call(propValue);\n                                    var step;\n                                    if (iteratorFn !== propValue.entries) {\n                                        while(!(step = iterator.next()).done){\n                                            if (!isNode(step.value)) {\n                                                return false;\n                                            }\n                                        }\n                                    } else {\n                                        // Iterator will provide entry [k,v] tuples rather than values.\n                                        while(!(step = iterator.next()).done){\n                                            var entry = step.value;\n                                            if (entry) {\n                                                if (!isNode(entry[1])) {\n                                                    return false;\n                                                }\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    return false;\n                                }\n                                return true;\n                            default:\n                                return false;\n                        }\n                    }\n                    function isSymbol(propType, propValue) {\n                        // Native Symbol.\n                        if (propType === \"symbol\") {\n                            return true;\n                        }\n                        // falsy value can't be a Symbol\n                        if (!propValue) {\n                            return false;\n                        }\n                        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n                        if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n                            return true;\n                        }\n                        // Fallback for non-spec compliant Symbols which are polyfilled.\n                        if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n                            return true;\n                        }\n                        return false;\n                    }\n                    // Equivalent of `typeof` but with special handling for array and regexp.\n                    function getPropType(propValue) {\n                        var propType = typeof propValue;\n                        if (Array.isArray(propValue)) {\n                            return \"array\";\n                        }\n                        if (propValue instanceof RegExp) {\n                            // Old webkits (at least until Android 4.0) return 'function' rather than\n                            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n                            // passes PropTypes.object.\n                            return \"object\";\n                        }\n                        if (isSymbol(propType, propValue)) {\n                            return \"symbol\";\n                        }\n                        return propType;\n                    }\n                    // This handles more types than `getPropType`. Only used for error messages.\n                    // See `createPrimitiveTypeChecker`.\n                    function getPreciseType(propValue) {\n                        if (typeof propValue === \"undefined\" || propValue === null) {\n                            return \"\" + propValue;\n                        }\n                        var propType = getPropType(propValue);\n                        if (propType === \"object\") {\n                            if (propValue instanceof Date) {\n                                return \"date\";\n                            } else if (propValue instanceof RegExp) {\n                                return \"regexp\";\n                            }\n                        }\n                        return propType;\n                    }\n                    // Returns a string that is postfixed to a warning about an invalid type.\n                    // For example, \"undefined\" or \"of type array\"\n                    function getPostfixForTypeWarning(value) {\n                        var type = getPreciseType(value);\n                        switch(type){\n                            case \"array\":\n                            case \"object\":\n                                return \"an \" + type;\n                            case \"boolean\":\n                            case \"date\":\n                            case \"regexp\":\n                                return \"a \" + type;\n                            default:\n                                return type;\n                        }\n                    }\n                    // Returns class name of the object, if any.\n                    function getClassName(propValue) {\n                        if (!propValue.constructor || !propValue.constructor.name) {\n                            return ANONYMOUS;\n                        }\n                        return propValue.constructor.name;\n                    }\n                    ReactPropTypes.checkPropTypes = checkPropTypes;\n                    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n                    ReactPropTypes.PropTypes = ReactPropTypes;\n                    return ReactPropTypes;\n                };\n            /***/ },\n            /***/ \"./node_modules/prop-types/index.js\": /*!******************************************!*\\\n  !*** ./node_modules/prop-types/index.js ***!\n  \\******************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_53409__)=>{\n                /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ if (true) {\n                    var ReactIs = __nested_webpack_require_53409__(/*! react-is */ \"./node_modules/react-is/index.js\");\n                    // By explicitly using `prop-types` you are opting into new development behavior.\n                    // http://fb.me/prop-types-in-prod\n                    var throwOnDirectAccess = true;\n                    module1.exports = __nested_webpack_require_53409__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n                } else {}\n            /***/ },\n            /***/ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!\n  \\*************************************************************/ /***/ (module1)=>{\n                \"use strict\";\n                /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n                module1.exports = ReactPropTypesSecret;\n            /***/ },\n            /***/ \"./node_modules/prop-types/lib/has.js\": /*!********************************************!*\\\n  !*** ./node_modules/prop-types/lib/has.js ***!\n  \\********************************************/ /***/ (module1)=>{\n                module1.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n            /***/ },\n            /***/ \"./node_modules/react-is/cjs/react-is.development.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/react-is/cjs/react-is.development.js ***!\n  \\***********************************************************/ /***/ (__unused_webpack_module, exports1)=>{\n                \"use strict\";\n                /** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ if (true) {\n                    (function() {\n                        \"use strict\";\n                        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n                        // nor polyfill, then a plain number is used for performance.\n                        var hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n                        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\"react.element\") : 0xeac7;\n                        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\"react.portal\") : 0xeaca;\n                        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\"react.fragment\") : 0xeacb;\n                        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.strict_mode\") : 0xeacc;\n                        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\"react.profiler\") : 0xead2;\n                        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\"react.provider\") : 0xeacd;\n                        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\"react.context\") : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n                        // (unstable) APIs that have been removed. Can we remove the symbols?\n                        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\"react.async_mode\") : 0xeacf;\n                        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.concurrent_mode\") : 0xeacf;\n                        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for(\"react.forward_ref\") : 0xead0;\n                        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for(\"react.suspense\") : 0xead1;\n                        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for(\"react.suspense_list\") : 0xead8;\n                        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for(\"react.memo\") : 0xead3;\n                        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for(\"react.lazy\") : 0xead4;\n                        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for(\"react.block\") : 0xead9;\n                        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for(\"react.fundamental\") : 0xead5;\n                        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for(\"react.responder\") : 0xead6;\n                        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for(\"react.scope\") : 0xead7;\n                        function isValidElementType(type) {\n                            return typeof type === \"string\" || typeof type === \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n                            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n                        }\n                        function typeOf(object) {\n                            if (typeof object === \"object\" && object !== null) {\n                                var $$typeof = object.$$typeof;\n                                switch($$typeof){\n                                    case REACT_ELEMENT_TYPE:\n                                        var type = object.type;\n                                        switch(type){\n                                            case REACT_ASYNC_MODE_TYPE:\n                                            case REACT_CONCURRENT_MODE_TYPE:\n                                            case REACT_FRAGMENT_TYPE:\n                                            case REACT_PROFILER_TYPE:\n                                            case REACT_STRICT_MODE_TYPE:\n                                            case REACT_SUSPENSE_TYPE:\n                                                return type;\n                                            default:\n                                                var $$typeofType = type && type.$$typeof;\n                                                switch($$typeofType){\n                                                    case REACT_CONTEXT_TYPE:\n                                                    case REACT_FORWARD_REF_TYPE:\n                                                    case REACT_LAZY_TYPE:\n                                                    case REACT_MEMO_TYPE:\n                                                    case REACT_PROVIDER_TYPE:\n                                                        return $$typeofType;\n                                                    default:\n                                                        return $$typeof;\n                                                }\n                                        }\n                                    case REACT_PORTAL_TYPE:\n                                        return $$typeof;\n                                }\n                            }\n                            return undefined;\n                        } // AsyncMode is deprecated along with isAsyncMode\n                        var AsyncMode = REACT_ASYNC_MODE_TYPE;\n                        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\n                        var ContextConsumer = REACT_CONTEXT_TYPE;\n                        var ContextProvider = REACT_PROVIDER_TYPE;\n                        var Element = REACT_ELEMENT_TYPE;\n                        var ForwardRef = REACT_FORWARD_REF_TYPE;\n                        var Fragment = REACT_FRAGMENT_TYPE;\n                        var Lazy = REACT_LAZY_TYPE;\n                        var Memo = REACT_MEMO_TYPE;\n                        var Portal = REACT_PORTAL_TYPE;\n                        var Profiler = REACT_PROFILER_TYPE;\n                        var StrictMode = REACT_STRICT_MODE_TYPE;\n                        var Suspense = REACT_SUSPENSE_TYPE;\n                        var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n                        function isAsyncMode(object) {\n                            {\n                                if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n                                    hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n                                    console[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, \" + \"and will be removed in React 17+. Update your code to use \" + \"ReactIs.isConcurrentMode() instead. It has the exact same API.\");\n                                }\n                            }\n                            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n                        }\n                        function isConcurrentMode(object) {\n                            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n                        }\n                        function isContextConsumer(object) {\n                            return typeOf(object) === REACT_CONTEXT_TYPE;\n                        }\n                        function isContextProvider(object) {\n                            return typeOf(object) === REACT_PROVIDER_TYPE;\n                        }\n                        function isElement(object) {\n                            return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n                        }\n                        function isForwardRef(object) {\n                            return typeOf(object) === REACT_FORWARD_REF_TYPE;\n                        }\n                        function isFragment(object) {\n                            return typeOf(object) === REACT_FRAGMENT_TYPE;\n                        }\n                        function isLazy(object) {\n                            return typeOf(object) === REACT_LAZY_TYPE;\n                        }\n                        function isMemo(object) {\n                            return typeOf(object) === REACT_MEMO_TYPE;\n                        }\n                        function isPortal(object) {\n                            return typeOf(object) === REACT_PORTAL_TYPE;\n                        }\n                        function isProfiler(object) {\n                            return typeOf(object) === REACT_PROFILER_TYPE;\n                        }\n                        function isStrictMode(object) {\n                            return typeOf(object) === REACT_STRICT_MODE_TYPE;\n                        }\n                        function isSuspense(object) {\n                            return typeOf(object) === REACT_SUSPENSE_TYPE;\n                        }\n                        exports1.AsyncMode = AsyncMode;\n                        exports1.ConcurrentMode = ConcurrentMode;\n                        exports1.ContextConsumer = ContextConsumer;\n                        exports1.ContextProvider = ContextProvider;\n                        exports1.Element = Element;\n                        exports1.ForwardRef = ForwardRef;\n                        exports1.Fragment = Fragment;\n                        exports1.Lazy = Lazy;\n                        exports1.Memo = Memo;\n                        exports1.Portal = Portal;\n                        exports1.Profiler = Profiler;\n                        exports1.StrictMode = StrictMode;\n                        exports1.Suspense = Suspense;\n                        exports1.isAsyncMode = isAsyncMode;\n                        exports1.isConcurrentMode = isConcurrentMode;\n                        exports1.isContextConsumer = isContextConsumer;\n                        exports1.isContextProvider = isContextProvider;\n                        exports1.isElement = isElement;\n                        exports1.isForwardRef = isForwardRef;\n                        exports1.isFragment = isFragment;\n                        exports1.isLazy = isLazy;\n                        exports1.isMemo = isMemo;\n                        exports1.isPortal = isPortal;\n                        exports1.isProfiler = isProfiler;\n                        exports1.isStrictMode = isStrictMode;\n                        exports1.isSuspense = isSuspense;\n                        exports1.isValidElementType = isValidElementType;\n                        exports1.typeOf = typeOf;\n                    })();\n                }\n            /***/ },\n            /***/ \"./node_modules/react-is/index.js\": /*!****************************************!*\\\n  !*** ./node_modules/react-is/index.js ***!\n  \\****************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_66680__)=>{\n                \"use strict\";\n                if (false) {} else {\n                    module1.exports = __nested_webpack_require_66680__(/*! ./cjs/react-is.development.js */ \"./node_modules/react-is/cjs/react-is.development.js\");\n                }\n            /***/ },\n            /***/ \"./node_modules/shallow-equal/dist/index.esm.js\": /*!******************************************************!*\\\n  !*** ./node_modules/shallow-equal/dist/index.esm.js ***!\n  \\******************************************************/ /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_67261__)=>{\n                \"use strict\";\n                __nested_webpack_require_67261__.r(__nested_webpack_exports__);\n                /* harmony export */ __nested_webpack_require_67261__.d(__nested_webpack_exports__, {\n                    /* harmony export */ \"shallowEqualArrays\": ()=>/* binding */ shallowEqualArrays,\n                    /* harmony export */ \"shallowEqualObjects\": ()=>/* binding */ shallowEqualObjects\n                });\n                function shallowEqualObjects(objA, objB) {\n                    if (objA === objB) {\n                        return true;\n                    }\n                    if (!objA || !objB) {\n                        return false;\n                    }\n                    var aKeys = Object.keys(objA);\n                    var bKeys = Object.keys(objB);\n                    var len = aKeys.length;\n                    if (bKeys.length !== len) {\n                        return false;\n                    }\n                    for(var i = 0; i < len; i++){\n                        var key = aKeys[i];\n                        if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function shallowEqualArrays(arrA, arrB) {\n                    if (arrA === arrB) {\n                        return true;\n                    }\n                    if (!arrA || !arrB) {\n                        return false;\n                    }\n                    var len = arrA.length;\n                    if (arrB.length !== len) {\n                        return false;\n                    }\n                    for(var i = 0; i < len; i++){\n                        if (arrA[i] !== arrB[i]) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            /***/ },\n            /***/ \"./src/Component.ts\": /*!**************************!*\\\n  !*** ./src/Component.ts ***!\n  \\**************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_69395__) {\n                \"use strict\";\n                var __rest = this && this.__rest || function(s, e) {\n                    var t = {};\n                    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n                    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n                    }\n                    return t;\n                };\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var useMediaQuery_1 = __importDefault(__nested_webpack_require_69395__(/*! ./useMediaQuery */ \"./src/useMediaQuery.ts\"));\n                // ReactNode and ReactElement typings are a little funky for functional components, so the ReactElement cast is needed on the return\n                var MediaQuery = function(_a) {\n                    var children = _a.children, device = _a.device, onChange = _a.onChange, settings = __rest(_a, [\n                        \"children\",\n                        \"device\",\n                        \"onChange\"\n                    ]);\n                    var matches = (0, useMediaQuery_1.default)(settings, device, onChange);\n                    if (typeof children === \"function\") {\n                        return children(matches);\n                    }\n                    return matches ? children : null;\n                };\n                exports1[\"default\"] = MediaQuery;\n            /***/ },\n            /***/ \"./src/Context.ts\": /*!************************!*\\\n  !*** ./src/Context.ts ***!\n  \\************************/ /***/ (__unused_webpack_module, exports1, __nested_webpack_require_71464__)=>{\n                \"use strict\";\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var react_1 = __nested_webpack_require_71464__(/*! react */ \"react\");\n                var Context = (0, react_1.createContext)(undefined);\n                exports1[\"default\"] = Context;\n            /***/ },\n            /***/ \"./src/index.ts\": /*!**********************!*\\\n  !*** ./src/index.ts ***!\n  \\**********************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_72013__) {\n                \"use strict\";\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.Context = exports1.toQuery = exports1.useMediaQuery = exports1[\"default\"] = void 0;\n                var useMediaQuery_1 = __importDefault(__nested_webpack_require_72013__(/*! ./useMediaQuery */ \"./src/useMediaQuery.ts\"));\n                exports1.useMediaQuery = useMediaQuery_1.default;\n                var Component_1 = __importDefault(__nested_webpack_require_72013__(/*! ./Component */ \"./src/Component.ts\"));\n                exports1[\"default\"] = Component_1.default;\n                var toQuery_1 = __importDefault(__nested_webpack_require_72013__(/*! ./toQuery */ \"./src/toQuery.ts\"));\n                exports1.toQuery = toQuery_1.default;\n                var Context_1 = __importDefault(__nested_webpack_require_72013__(/*! ./Context */ \"./src/Context.ts\"));\n                exports1.Context = Context_1.default;\n            /***/ },\n            /***/ \"./src/mediaQuery.ts\": /*!***************************!*\\\n  !*** ./src/mediaQuery.ts ***!\n  \\***************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_73412__) {\n                \"use strict\";\n                var __assign = this && this.__assign || function() {\n                    __assign = Object.assign || function(t) {\n                        for(var s, i = 1, n = arguments.length; i < n; i++){\n                            s = arguments[i];\n                            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n                        }\n                        return t;\n                    };\n                    return __assign.apply(this, arguments);\n                };\n                var __rest = this && this.__rest || function(s, e) {\n                    var t = {};\n                    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n                    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n                    }\n                    return t;\n                };\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var prop_types_1 = __importDefault(__nested_webpack_require_73412__(/*! prop-types */ \"./node_modules/prop-types/index.js\"));\n                var stringOrNumber = prop_types_1.default.oneOfType([\n                    prop_types_1.default.string,\n                    prop_types_1.default.number\n                ]);\n                // media types\n                var types = {\n                    all: prop_types_1.default.bool,\n                    grid: prop_types_1.default.bool,\n                    aural: prop_types_1.default.bool,\n                    braille: prop_types_1.default.bool,\n                    handheld: prop_types_1.default.bool,\n                    print: prop_types_1.default.bool,\n                    projection: prop_types_1.default.bool,\n                    screen: prop_types_1.default.bool,\n                    tty: prop_types_1.default.bool,\n                    tv: prop_types_1.default.bool,\n                    embossed: prop_types_1.default.bool\n                };\n                // properties that match media queries\n                var matchers = {\n                    orientation: prop_types_1.default.oneOf([\n                        \"portrait\",\n                        \"landscape\"\n                    ]),\n                    scan: prop_types_1.default.oneOf([\n                        \"progressive\",\n                        \"interlace\"\n                    ]),\n                    aspectRatio: prop_types_1.default.string,\n                    deviceAspectRatio: prop_types_1.default.string,\n                    height: stringOrNumber,\n                    deviceHeight: stringOrNumber,\n                    width: stringOrNumber,\n                    deviceWidth: stringOrNumber,\n                    color: prop_types_1.default.bool,\n                    colorIndex: prop_types_1.default.bool,\n                    monochrome: prop_types_1.default.bool,\n                    resolution: stringOrNumber,\n                    type: Object.keys(types)\n                };\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var type = matchers.type, featureMatchers = __rest(matchers, [\n                    \"type\"\n                ]);\n                // media features\n                var features = __assign({\n                    minAspectRatio: prop_types_1.default.string,\n                    maxAspectRatio: prop_types_1.default.string,\n                    minDeviceAspectRatio: prop_types_1.default.string,\n                    maxDeviceAspectRatio: prop_types_1.default.string,\n                    minHeight: stringOrNumber,\n                    maxHeight: stringOrNumber,\n                    minDeviceHeight: stringOrNumber,\n                    maxDeviceHeight: stringOrNumber,\n                    minWidth: stringOrNumber,\n                    maxWidth: stringOrNumber,\n                    minDeviceWidth: stringOrNumber,\n                    maxDeviceWidth: stringOrNumber,\n                    minColor: prop_types_1.default.number,\n                    maxColor: prop_types_1.default.number,\n                    minColorIndex: prop_types_1.default.number,\n                    maxColorIndex: prop_types_1.default.number,\n                    minMonochrome: prop_types_1.default.number,\n                    maxMonochrome: prop_types_1.default.number,\n                    minResolution: stringOrNumber,\n                    maxResolution: stringOrNumber\n                }, featureMatchers);\n                var all = __assign(__assign({}, types), features);\n                exports1[\"default\"] = {\n                    all: all,\n                    types: types,\n                    matchers: matchers,\n                    features: features\n                };\n            /***/ },\n            /***/ \"./src/toQuery.ts\": /*!************************!*\\\n  !*** ./src/toQuery.ts ***!\n  \\************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_78821__) {\n                \"use strict\";\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var hyphenate_style_name_1 = __importDefault(__nested_webpack_require_78821__(/*! hyphenate-style-name */ \"./node_modules/hyphenate-style-name/index.js\"));\n                var mediaQuery_1 = __importDefault(__nested_webpack_require_78821__(/*! ./mediaQuery */ \"./src/mediaQuery.ts\"));\n                var negate = function(cond) {\n                    return \"not \".concat(cond);\n                };\n                var keyVal = function(k, v) {\n                    var realKey = (0, hyphenate_style_name_1.default)(k);\n                    // px shorthand\n                    if (typeof v === \"number\") {\n                        v = \"\".concat(v, \"px\");\n                    }\n                    if (v === true) {\n                        return realKey;\n                    }\n                    if (v === false) {\n                        return negate(realKey);\n                    }\n                    return \"(\".concat(realKey, \": \").concat(v, \")\");\n                };\n                var join = function(conds) {\n                    return conds.join(\" and \");\n                };\n                var toQuery = function(obj) {\n                    var rules = [];\n                    Object.keys(mediaQuery_1.default.all).forEach(function(k) {\n                        var v = obj[k];\n                        if (v != null) {\n                            rules.push(keyVal(k, v));\n                        }\n                    });\n                    return join(rules);\n                };\n                exports1[\"default\"] = toQuery;\n            /***/ },\n            /***/ \"./src/useMediaQuery.ts\": /*!******************************!*\\\n  !*** ./src/useMediaQuery.ts ***!\n  \\******************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_80963__) {\n                \"use strict\";\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var react_1 = __nested_webpack_require_80963__(/*! react */ \"react\");\n                var matchmediaquery_1 = __importDefault(__nested_webpack_require_80963__(/*! matchmediaquery */ \"./node_modules/matchmediaquery/index.js\"));\n                var hyphenate_style_name_1 = __importDefault(__nested_webpack_require_80963__(/*! hyphenate-style-name */ \"./node_modules/hyphenate-style-name/index.js\"));\n                var shallow_equal_1 = __nested_webpack_require_80963__(/*! shallow-equal */ \"./node_modules/shallow-equal/dist/index.esm.js\");\n                var toQuery_1 = __importDefault(__nested_webpack_require_80963__(/*! ./toQuery */ \"./src/toQuery.ts\"));\n                var Context_1 = __importDefault(__nested_webpack_require_80963__(/*! ./Context */ \"./src/Context.ts\"));\n                var makeQuery = function(settings) {\n                    return settings.query || (0, toQuery_1.default)(settings);\n                };\n                var hyphenateKeys = function(obj) {\n                    if (!obj) return undefined;\n                    var keys = Object.keys(obj);\n                    return keys.reduce(function(result, key) {\n                        result[(0, hyphenate_style_name_1.default)(key)] = obj[key];\n                        return result;\n                    }, {});\n                };\n                var useIsUpdate = function() {\n                    var ref = (0, react_1.useRef)(false);\n                    (0, react_1.useEffect)(function() {\n                        ref.current = true;\n                    }, []);\n                    return ref.current;\n                };\n                var useDevice = function(deviceFromProps) {\n                    var deviceFromContext = (0, react_1.useContext)(Context_1.default);\n                    var getDevice = function() {\n                        return hyphenateKeys(deviceFromProps) || hyphenateKeys(deviceFromContext);\n                    };\n                    var _a = (0, react_1.useState)(getDevice), device = _a[0], setDevice = _a[1];\n                    (0, react_1.useEffect)(function() {\n                        var newDevice = getDevice();\n                        if (!(0, shallow_equal_1.shallowEqualObjects)(device, newDevice)) {\n                            setDevice(newDevice);\n                        }\n                    }, [\n                        deviceFromProps,\n                        deviceFromContext\n                    ]);\n                    return device;\n                };\n                var useQuery = function(settings) {\n                    var getQuery = function() {\n                        return makeQuery(settings);\n                    };\n                    var _a = (0, react_1.useState)(getQuery), query = _a[0], setQuery = _a[1];\n                    (0, react_1.useEffect)(function() {\n                        var newQuery = getQuery();\n                        if (query !== newQuery) {\n                            setQuery(newQuery);\n                        }\n                    }, [\n                        settings\n                    ]);\n                    return query;\n                };\n                var useMatchMedia = function(query, device) {\n                    var getMatchMedia = function() {\n                        return (0, matchmediaquery_1.default)(query, device || {}, !!device);\n                    };\n                    var _a = (0, react_1.useState)(getMatchMedia), mq = _a[0], setMq = _a[1];\n                    var isUpdate = useIsUpdate();\n                    (0, react_1.useEffect)(function() {\n                        if (isUpdate) {\n                            // skip on mounting, it has already been set\n                            var newMq_1 = getMatchMedia();\n                            setMq(newMq_1);\n                            return function() {\n                                if (newMq_1) {\n                                    newMq_1.dispose();\n                                }\n                            };\n                        }\n                    }, [\n                        query,\n                        device\n                    ]);\n                    return mq;\n                };\n                var useMatches = function(mediaQuery) {\n                    var _a = (0, react_1.useState)(mediaQuery.matches), matches = _a[0], setMatches = _a[1];\n                    (0, react_1.useEffect)(function() {\n                        var updateMatches = function(ev) {\n                            setMatches(ev.matches);\n                        };\n                        mediaQuery.addListener(updateMatches);\n                        setMatches(mediaQuery.matches);\n                        return function() {\n                            mediaQuery.removeListener(updateMatches);\n                        };\n                    }, [\n                        mediaQuery\n                    ]);\n                    return matches;\n                };\n                var useMediaQuery = function(settings, device, onChange) {\n                    var deviceSettings = useDevice(device);\n                    var query = useQuery(settings);\n                    if (!query) throw new Error(\"Invalid or missing MediaQuery!\");\n                    var mq = useMatchMedia(query, deviceSettings);\n                    var matches = useMatches(mq);\n                    var isUpdate = useIsUpdate();\n                    (0, react_1.useEffect)(function() {\n                        if (isUpdate && onChange) {\n                            onChange(matches);\n                        }\n                    }, [\n                        matches\n                    ]);\n                    (0, react_1.useEffect)(function() {\n                        return function() {\n                            if (mq) {\n                                mq.dispose();\n                            }\n                        };\n                    }, []);\n                    return matches;\n                };\n                exports1[\"default\"] = useMediaQuery;\n            /***/ },\n            /***/ \"react\": /*!**************************************************************************************!*\\\n  !*** external {\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\",\"root\":\"React\"} ***!\n  \\**************************************************************************************/ /***/ (module1)=>{\n                \"use strict\";\n                module1.exports = __WEBPACK_EXTERNAL_MODULE_react__;\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_88007__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_88007__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{\n            /******/ // define getter functions for harmony exports\n            /******/ __nested_webpack_require_88007__.d = (exports1, definition)=>{\n                /******/ for(var key in definition){\n                    /******/ if (__nested_webpack_require_88007__.o(definition, key) && !__nested_webpack_require_88007__.o(exports1, key)) {\n                        /******/ Object.defineProperty(exports1, key, {\n                            enumerable: true,\n                            get: definition[key]\n                        });\n                    /******/ }\n                /******/ }\n            /******/ };\n        /******/ })();\n        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{\n            /******/ __nested_webpack_require_88007__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);\n        /******/ })();\n        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{\n            /******/ // define __esModule on exports\n            /******/ __nested_webpack_require_88007__.r = (exports1)=>{\n                /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                        value: \"Module\"\n                    });\n                /******/ }\n                /******/ Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /******/ };\n        /******/ })();\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_88007__(\"./src/index.ts\");\n        /******/ /******/ return __nested_webpack_exports__;\n    /******/ })();\n}); //# sourceMappingURL=react-responsive.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzcG9uc2l2ZS9kaXN0L3JlYWN0LXJlc3BvbnNpdmUuanMiLCJtYXBwaW5ncyI6IjtBQUFBLFVBQUFBLGlDQUFBQyxJQUFBLEVBQUFDLE9BQUE7SUFDQSxVQUNBRSxPQUFBRCxPQUFBLEdBQUFELFFBQUFHLG1CQUFBQSxDQUFBO1NBQ0EsRUFLQTtBQUNBLEdBQUMsU0FBQUc7SUFDRDs7Ozs7O2dCQ1ZBOzs7O0FBSUEsR0FJQUwsU0FBQU0sS0FBYSxHQUFBQztnQkFDYlAsU0FBQVEsS0FBYSxHQUFBQztnQkFFYjtnQkFFQSxJQUFBQyxpQkFBQSx1REFDQUMsbUJBQUEsaURBQ0FDLGdCQUFBLHdCQUNBQyxpQkFBQSxnQ0FDQUMscUJBQUE7Z0JBRUEsU0FBQVAsV0FBQVEsVUFBQSxFQUFBQyxNQUFBO29CQUNBLE9BQUFQLFdBQUFNLFlBQUFFLElBQUEsVUFBQUMsS0FBQTt3QkFDQSxJQUFBQyxVQUFBRCxNQUFBQyxPQUFBO3dCQUVBO3dCQUNBO3dCQUNBLElBQUFDLFlBQUFGLE1BQUFHLElBQUEsY0FBQUwsT0FBQUssSUFBQSxLQUFBSCxNQUFBRyxJQUFBO3dCQUVBO3dCQUNBLGlCQUFBRixXQUFBLENBQUFDLENBQUFBLGFBQUFELE9BQUE7NEJBQ0E7d0JBQ0E7d0JBRUEsSUFBQUcsbUJBQUFKLE1BQUFLLFdBQUEsQ0FBQUMsS0FBQSxVQUFBQyxVQUFBOzRCQUNBLElBQUFDLFVBQUFELFdBQUFDLE9BQUEsRUFDQUMsV0FBQUYsV0FBQUUsUUFBQSxFQUNBQyxXQUFBSCxXQUFBSSxLQUFBLEVBQ0FBLFFBQUFiLE1BQUEsQ0FBQVUsUUFBQTs0QkFFQTs0QkFDQSxLQUFBRyxPQUFBO2dDQUEwQjs0QkFBQTs0QkFFMUIsT0FBQUg7Z0NBQ0E7Z0NBQ0E7b0NBQ0EsT0FBQUcsTUFBQUMsV0FBQSxPQUFBRixTQUFBRSxXQUFBO2dDQUVBO2dDQUNBO2dDQUNBO2dDQUNBO29DQUNBRixXQUFBRyxLQUFBSDtvQ0FDQUMsUUFBQUUs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QUFBO2lDQUNBOUIsT0FBQTJVLGNBQUEsQ0FBQTFaLFVBQUE2RyxLQUFBOzRCQUF5QzhTLFlBQUE7NEJBQUFDLEtBQUFKLFVBQUEsQ0FBQTNTLElBQUE7d0JBQUE7NkJBQ3pDO3lCQUNBO3FCQUNBOzs7cUJDUEFoRCxnQ0FBbUJBLENBQW5CNFYsQ0FBQSxJQUFBMUMsS0FBQThDLE9BQUE5VSxPQUFBQyxTQUFBLENBQUF6QixjQUFBLENBQUFjLElBQUEsQ0FBQTBTLEtBQUE4Qzs7O3FCQ0FBO3FCQUNBaFcsZ0NBQW1CQSxDQUFuQmlXLENBQUEsSUFBQTlaO3lCQUNBLFdBQUFzSSxXQUFBLGVBQUFBLE9BQUF5UixXQUFBOzZCQUNBaFYsT0FBQTJVLGNBQUEsQ0FBQTFaLFVBQUFzSSxPQUFBeVIsV0FBQTt3QkFBdURsWSxPQUFBO29CQUFBO3lCQUN2RDt5QkFDQWtELE9BQUEyVSxjQUFBLENBQUExWixVQUFBO29CQUFnRDZCLE9BQUE7Z0JBQUE7cUJBQ2hEOzs4R0VOQTtpQkFDQTtpQkFDQTtpQkFDQSxJQUFBbVksMEJBQUFBLEdBQUFuVyxnQ0FBQUEsQ0FBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Rldi9NZWRpYVF1ZXJ5L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbj80ZDVhIiwid2VicGFjazovL2Rldi9NZWRpYVF1ZXJ5Ly4vbm9kZV9tb2R1bGVzL2Nzcy1tZWRpYXF1ZXJ5L2luZGV4LmpzP2NhMTYiLCJ3ZWJwYWNrOi8vZGV2L01lZGlhUXVlcnkvLi9ub2RlX21vZHVsZXMvaHlwaGVuYXRlLXN0eWxlLW5hbWUvaW5kZXguanM/N2U1NyIsIndlYnBhY2s6Ly9kZXYvTWVkaWFRdWVyeS8uL25vZGVfbW9kdWxlcy9tYXRjaG1lZGlhcXVlcnkvaW5kZXguanM/MTVjOSIsIndlYnBhY2s6Ly9kZXYvTWVkaWFRdWVyeS8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzP2I1YWMiLCJ3ZWJwYWNrOi8vZGV2L01lZGlhUXVlcnkvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcz9mM2I4Iiwid2VicGFjazovL2Rldi9NZWRpYVF1ZXJ5Ly4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanM/MTI4NCIsIndlYnBhY2s6Ly9kZXYvTWVkaWFRdWVyeS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzPzM2NWQiLCJ3ZWJwYWNrOi8vZGV2L01lZGlhUXVlcnkvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanM/M2RhYiIsIndlYnBhY2s6Ly9kZXYvTWVkaWFRdWVyeS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanM/YzExOSIsIndlYnBhY2s6Ly9kZXYvTWVkaWFRdWVyeS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanM/Mjk0OSIsIndlYnBhY2s6Ly9kZXYvTWVkaWFRdWVyeS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcz8xNzYyIiwid2VicGFjazovL2Rldi9NZWRpYVF1ZXJ5Ly4vbm9kZV9tb2R1bGVzL3NoYWxsb3ctZXF1YWwvZGlzdC9pbmRleC5lc20uanM/ZDkzYSIsIndlYnBhY2s6Ly9kZXYvTWVkaWFRdWVyeS8uL3NyYy9Db21wb25lbnQudHM/MmEyMiIsIndlYnBhY2s6Ly9kZXYvTWVkaWFRdWVyeS8uL3NyYy9Db250ZXh0LnRzP2EzN2QiLCJ3ZWJwYWNrOi8vZGV2L01lZGlhUXVlcnkvLi9zcmMvaW5kZXgudHM/MWM4MiIsIndlYnBhY2s6Ly9kZXYvTWVkaWFRdWVyeS8uL3NyYy9tZWRpYVF1ZXJ5LnRzP2MyNDAiLCJ3ZWJwYWNrOi8vZGV2L01lZGlhUXVlcnkvLi9zcmMvdG9RdWVyeS50cz9iYTAzIiwid2VicGFjazovL2Rldi9NZWRpYVF1ZXJ5Ly4vc3JjL3VzZU1lZGlhUXVlcnkudHM/NDYxYiIsIndlYnBhY2s6Ly9kZXYvTWVkaWFRdWVyeS9leHRlcm5hbCB1bWQge1wiY29tbW9uanNcIjpcInJlYWN0XCIsXCJjb21tb25qczJcIjpcInJlYWN0XCIsXCJhbWRcIjpcInJlYWN0XCIsXCJyb290XCI6XCJSZWFjdFwifT80OGFmIiwid2VicGFjazovL2Rldi9NZWRpYVF1ZXJ5L3dlYnBhY2svYm9vdHN0cmFwP2Y3OWUiLCJ3ZWJwYWNrOi8vZGV2L01lZGlhUXVlcnkvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzPzU4NjQiLCJ3ZWJwYWNrOi8vZGV2L01lZGlhUXVlcnkvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZD9jMDc0Iiwid2VicGFjazovL2Rldi9NZWRpYVF1ZXJ5L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3Q/YTgxYyIsIndlYnBhY2s6Ly9kZXYvTWVkaWFRdWVyeS93ZWJwYWNrL2JlZm9yZS1zdGFydHVwP2NiNjMiLCJ3ZWJwYWNrOi8vZGV2L01lZGlhUXVlcnkvd2VicGFjay9zdGFydHVwPzliN2UiLCJ3ZWJwYWNrOi8vZGV2L01lZGlhUXVlcnkvd2VicGFjay9hZnRlci1zdGFydHVwPzZmNGEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicmVhY3RcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiTWVkaWFRdWVyeVwiXSA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJNZWRpYVF1ZXJ5XCJdID0gZmFjdG9yeShyb290W1wiUmVhY3RcIl0pO1xufSkodGhpcywgKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfcmVhY3RfXykgPT4ge1xucmV0dXJuICIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTQsIFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5Db3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuXG5TZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLm1hdGNoID0gbWF0Y2hRdWVyeTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZVF1ZXJ5O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgUkVfTUVESUFfUVVFUlkgICAgID0gLyg/Oihvbmx5fG5vdCk/XFxzKihbXlxcc1xcKFxcKV0rKSg/OlxccyphbmQpP1xccyopPyguKyk/L2ksXG4gICAgUkVfTVFfRVhQUkVTU0lPTiAgID0gL1xcKFxccyooW15cXHNcXDpcXCldKylcXHMqKD86XFw6XFxzKihbXlxcc1xcKV0rKSk/XFxzKlxcKS8sXG4gICAgUkVfTVFfRkVBVFVSRSAgICAgID0gL14oPzoobWlufG1heCktKT8oLispLyxcbiAgICBSRV9MRU5HVEhfVU5JVCAgICAgPSAvKGVtfHJlbXxweHxjbXxtbXxpbnxwdHxwYyk/JC8sXG4gICAgUkVfUkVTT0xVVElPTl9VTklUID0gLyhkcGl8ZHBjbXxkcHB4KT8kLztcblxuZnVuY3Rpb24gbWF0Y2hRdWVyeShtZWRpYVF1ZXJ5LCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gcGFyc2VRdWVyeShtZWRpYVF1ZXJ5KS5zb21lKGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICB2YXIgaW52ZXJzZSA9IHF1ZXJ5LmludmVyc2U7XG5cbiAgICAgICAgLy8gRWl0aGVyIHRoZSBwYXJzZWQgb3Igc3BlY2lmaWVkIGB0eXBlYCBpcyBcImFsbFwiLCBvciB0aGUgdHlwZXMgbXVzdCBiZVxuICAgICAgICAvLyBlcXVhbCBmb3IgYSBtYXRjaC5cbiAgICAgICAgdmFyIHR5cGVNYXRjaCA9IHF1ZXJ5LnR5cGUgPT09ICdhbGwnIHx8IHZhbHVlcy50eXBlID09PSBxdWVyeS50eXBlO1xuXG4gICAgICAgIC8vIFF1aXQgZWFybHkgd2hlbiBgdHlwZWAgZG9lc24ndCBtYXRjaCwgYnV0IHRha2UgXCJub3RcIiBpbnRvIGFjY291bnQuXG4gICAgICAgIGlmICgodHlwZU1hdGNoICYmIGludmVyc2UpIHx8ICEodHlwZU1hdGNoIHx8IGludmVyc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwcmVzc2lvbnNNYXRjaCA9IHF1ZXJ5LmV4cHJlc3Npb25zLmV2ZXJ5KGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZSAgPSBleHByZXNzaW9uLmZlYXR1cmUsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXIgPSBleHByZXNzaW9uLm1vZGlmaWVyLFxuICAgICAgICAgICAgICAgIGV4cFZhbHVlID0gZXhwcmVzc2lvbi52YWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA9IHZhbHVlc1tmZWF0dXJlXTtcblxuICAgICAgICAgICAgLy8gTWlzc2luZyBvciBmYWxzeSB2YWx1ZXMgZG9uJ3QgbWF0Y2guXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdvcmllbnRhdGlvbic6XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Nhbic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBleHBWYWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnd2lkdGgnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGV2aWNlLXdpZHRoJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkZXZpY2UtaGVpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgZXhwVmFsdWUgPSB0b1B4KGV4cFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgPSB0b1B4KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdyZXNvbHV0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgZXhwVmFsdWUgPSB0b0RwaShleHBWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgID0gdG9EcGkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2FzcGVjdC1yYXRpbyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGV2aWNlLWFzcGVjdC1yYXRpbyc6XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBEZXByZWNhdGVkICovICdkZXZpY2UtcGl4ZWwtcmF0aW8nOlxuICAgICAgICAgICAgICAgICAgICBleHBWYWx1ZSA9IHRvRGVjaW1hbChleHBWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgID0gdG9EZWNpbWFsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdncmlkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb2xvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29sb3ItaW5kZXgnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ21vbm9jaHJvbWUnOlxuICAgICAgICAgICAgICAgICAgICBleHBWYWx1ZSA9IHBhcnNlSW50KGV4cFZhbHVlLCAxMCkgfHwgMTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgPSBwYXJzZUludCh2YWx1ZSwgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWluJzogcmV0dXJuIHZhbHVlID49IGV4cFZhbHVlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21heCc6IHJldHVybiB2YWx1ZSA8PSBleHBWYWx1ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0ICAgOiByZXR1cm4gdmFsdWUgPT09IGV4cFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gKGV4cHJlc3Npb25zTWF0Y2ggJiYgIWludmVyc2UpIHx8ICghZXhwcmVzc2lvbnNNYXRjaCAmJiBpbnZlcnNlKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VRdWVyeShtZWRpYVF1ZXJ5KSB7XG4gICAgcmV0dXJuIG1lZGlhUXVlcnkuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkudHJpbSgpO1xuXG4gICAgICAgIHZhciBjYXB0dXJlcyAgICA9IHF1ZXJ5Lm1hdGNoKFJFX01FRElBX1FVRVJZKSxcbiAgICAgICAgICAgIG1vZGlmaWVyICAgID0gY2FwdHVyZXNbMV0sXG4gICAgICAgICAgICB0eXBlICAgICAgICA9IGNhcHR1cmVzWzJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbnMgPSBjYXB0dXJlc1szXSB8fCAnJyxcbiAgICAgICAgICAgIHBhcnNlZCAgICAgID0ge307XG5cbiAgICAgICAgcGFyc2VkLmludmVyc2UgPSAhIW1vZGlmaWVyICYmIG1vZGlmaWVyLnRvTG93ZXJDYXNlKCkgPT09ICdub3QnO1xuICAgICAgICBwYXJzZWQudHlwZSAgICA9IHR5cGUgPyB0eXBlLnRvTG93ZXJDYXNlKCkgOiAnYWxsJztcblxuICAgICAgICAvLyBTcGxpdCBleHByZXNzaW9ucyBpbnRvIGEgbGlzdC5cbiAgICAgICAgZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucy5tYXRjaCgvXFwoW15cXCldK1xcKS9nKSB8fCBbXTtcblxuICAgICAgICBwYXJzZWQuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHZhciBjYXB0dXJlcyA9IGV4cHJlc3Npb24ubWF0Y2goUkVfTVFfRVhQUkVTU0lPTiksXG4gICAgICAgICAgICAgICAgZmVhdHVyZSAgPSBjYXB0dXJlc1sxXS50b0xvd2VyQ2FzZSgpLm1hdGNoKFJFX01RX0ZFQVRVUkUpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiBmZWF0dXJlWzFdLFxuICAgICAgICAgICAgICAgIGZlYXR1cmUgOiBmZWF0dXJlWzJdLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgOiBjYXB0dXJlc1syXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9KTtcbn1cblxuLy8gLS0gVXRpbGl0aWVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdG9EZWNpbWFsKHJhdGlvKSB7XG4gICAgdmFyIGRlY2ltYWwgPSBOdW1iZXIocmF0aW8pLFxuICAgICAgICBudW1iZXJzO1xuXG4gICAgaWYgKCFkZWNpbWFsKSB7XG4gICAgICAgIG51bWJlcnMgPSByYXRpby5tYXRjaCgvXihcXGQrKVxccypcXC9cXHMqKFxcZCspJC8pO1xuICAgICAgICBkZWNpbWFsID0gbnVtYmVyc1sxXSAvIG51bWJlcnNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY2ltYWw7XG59XG5cbmZ1bmN0aW9uIHRvRHBpKHJlc29sdXRpb24pIHtcbiAgICB2YXIgdmFsdWUgPSBwYXJzZUZsb2F0KHJlc29sdXRpb24pLFxuICAgICAgICB1bml0cyA9IFN0cmluZyhyZXNvbHV0aW9uKS5tYXRjaChSRV9SRVNPTFVUSU9OX1VOSVQpWzFdO1xuXG4gICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICdkcGNtJzogcmV0dXJuIHZhbHVlIC8gMi41NDtcbiAgICAgICAgY2FzZSAnZHBweCc6IHJldHVybiB2YWx1ZSAqIDk2O1xuICAgICAgICBkZWZhdWx0ICAgIDogcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9QeChsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBwYXJzZUZsb2F0KGxlbmd0aCksXG4gICAgICAgIHVuaXRzID0gU3RyaW5nKGxlbmd0aCkubWF0Y2goUkVfTEVOR1RIX1VOSVQpWzFdO1xuXG4gICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICdlbScgOiByZXR1cm4gdmFsdWUgKiAxNjtcbiAgICAgICAgY2FzZSAncmVtJzogcmV0dXJuIHZhbHVlICogMTY7XG4gICAgICAgIGNhc2UgJ2NtJyA6IHJldHVybiB2YWx1ZSAqIDk2IC8gMi41NDtcbiAgICAgICAgY2FzZSAnbW0nIDogcmV0dXJuIHZhbHVlICogOTYgLyAyLjU0IC8gMTA7XG4gICAgICAgIGNhc2UgJ2luJyA6IHJldHVybiB2YWx1ZSAqIDk2O1xuICAgICAgICBjYXNlICdwdCcgOiByZXR1cm4gdmFsdWUgKiA3MjtcbiAgICAgICAgY2FzZSAncGMnIDogcmV0dXJuIHZhbHVlICogNzIgLyAxMjtcbiAgICAgICAgZGVmYXVsdCAgIDogcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciwgcHJlZmVyLXRlbXBsYXRlICovXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC9bQS1aXS9nXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vXG52YXIgY2FjaGUgPSB7fVxuXG5mdW5jdGlvbiB0b0h5cGhlbkxvd2VyKG1hdGNoKSB7XG4gIHJldHVybiAnLScgKyBtYXRjaC50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShuYW1lKSB7XG4gIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHJldHVybiBjYWNoZVtuYW1lXVxuICB9XG5cbiAgdmFyIGhOYW1lID0gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sIHRvSHlwaGVuTG93ZXIpXG4gIHJldHVybiAoY2FjaGVbbmFtZV0gPSBtc1BhdHRlcm4udGVzdChoTmFtZSkgPyAnLScgKyBoTmFtZSA6IGhOYW1lKVxufVxuXG5leHBvcnQgZGVmYXVsdCBoeXBoZW5hdGVTdHlsZU5hbWVcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0YXRpY01hdGNoID0gcmVxdWlyZSgnY3NzLW1lZGlhcXVlcnknKS5tYXRjaDtcbnZhciBkeW5hbWljTWF0Y2ggPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5tYXRjaE1lZGlhIDogbnVsbDtcblxuLy8gb3VyIGZha2UgTWVkaWFRdWVyeUxpc3RcbmZ1bmN0aW9uIE1xbChxdWVyeSwgdmFsdWVzLCBmb3JjZVN0YXRpYyl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYoZHluYW1pY01hdGNoICYmICFmb3JjZVN0YXRpYyl7XG4gICAgdmFyIG1xbCA9IGR5bmFtaWNNYXRjaC5jYWxsKHdpbmRvdywgcXVlcnkpO1xuICAgIHRoaXMubWF0Y2hlcyA9IG1xbC5tYXRjaGVzO1xuICAgIHRoaXMubWVkaWEgPSBtcWwubWVkaWE7XG4gICAgLy8gVE9ETzogaXMgdGhlcmUgYSB0aW1lIGl0IG1ha2VzIHNlbnNlIHRvIHJlbW92ZSB0aGlzIGxpc3RlbmVyP1xuICAgIG1xbC5hZGRMaXN0ZW5lcih1cGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWF0Y2hlcyA9IHN0YXRpY01hdGNoKHF1ZXJ5LCB2YWx1ZXMpO1xuICAgIHRoaXMubWVkaWEgPSBxdWVyeTtcbiAgfVxuXG4gIHRoaXMuYWRkTGlzdGVuZXIgPSBhZGRMaXN0ZW5lcjtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IHJlbW92ZUxpc3RlbmVyO1xuICB0aGlzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVyKGxpc3RlbmVyKXtcbiAgICBpZihtcWwpe1xuICAgICAgbXFsLmFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcil7XG4gICAgaWYobXFsKXtcbiAgICAgIG1xbC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiAgLy8gdXBkYXRlIG91cnNlbHZlcyFcbiAgZnVuY3Rpb24gdXBkYXRlKGV2dCl7XG4gICAgc2VsZi5tYXRjaGVzID0gZXZ0Lm1hdGNoZXM7XG4gICAgc2VsZi5tZWRpYSA9IGV2dC5tZWRpYTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKXtcbiAgICBpZihtcWwpe1xuICAgICAgbXFsLnJlbW92ZUxpc3RlbmVyKHVwZGF0ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoTWVkaWEocXVlcnksIHZhbHVlcywgZm9yY2VTdGF0aWMpe1xuICByZXR1cm4gbmV3IE1xbChxdWVyeSwgdmFsdWVzLCBmb3JjZVN0YXRpYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hNZWRpYTtcbiIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vbGliL2hhcycpO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7IC8qKi8gfVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArXG4gICAgICAgICAgICAgICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vbGliL2hhcycpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYmlnaW50OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYmlnaW50JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UsIGRhdGEpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnID8gZGF0YToge307XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgcHJvcCBvbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJyksXG4gICAgICAgICAge2V4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIVJlYWN0SXMuaXNWYWxpZEVsZW1lbnRUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudHMgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LCBnb3QgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cy4gJyArXG4gICAgICAgICAgICAnQSBjb21tb24gbWlzdGFrZSBpcyB0byB3cml0ZSBvbmVPZih4LCB5LCB6KSBpbnN0ZWFkIG9mIG9uZU9mKFt4LCB5LCB6XSkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIFN0cmluZyhwcm9wVmFsdWUpICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChoYXMocHJvcFZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICB2YXIgY2hlY2tlclJlc3VsdCA9IGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tlclJlc3VsdC5kYXRhICYmIGhhcyhjaGVja2VyUmVzdWx0LmRhdGEsICdleHBlY3RlZFR5cGUnKSkge1xuICAgICAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChjaGVja2VyUmVzdWx0LmRhdGEuZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGV4cGVjdGVkVHlwZXNNZXNzYWdlID0gKGV4cGVjdGVkVHlwZXMubGVuZ3RoID4gMCkgPyAnLCBleHBlY3RlZCBvbmUgb2YgdHlwZSBbJyArIGV4cGVjdGVkVHlwZXMuam9pbignLCAnKSArICddJzogJyc7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgJyArIGV4cGVjdGVkVHlwZXNNZXNzYWdlICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCB0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXkgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGUgKyAnYC4nXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgZ2V0UHJlY2lzZVR5cGUoY2hlY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKGhhcyhzaGFwZVR5cGVzLCBrZXkpICYmIHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIGdldFByZWNpc2VUeXBlKGNoZWNrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiZnVuY3Rpb24gc2hhbGxvd0VxdWFsT2JqZWN0cyhvYmpBLCBvYmpCKSB7XG4gIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIW9iakEgfHwgIW9iakIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMob2JqQik7XG4gIHZhciBsZW4gPSBhS2V5cy5sZW5ndGg7XG5cbiAgaWYgKGJLZXlzLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBrZXkgPSBhS2V5c1tpXTtcblxuICAgIGlmIChvYmpBW2tleV0gIT09IG9iakJba2V5XSB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsQXJyYXlzKGFyckEsIGFyckIpIHtcbiAgaWYgKGFyckEgPT09IGFyckIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghYXJyQSB8fCAhYXJyQikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW4gPSBhcnJBLmxlbmd0aDtcblxuICBpZiAoYXJyQi5sZW5ndGggIT09IGxlbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXJyQVtpXSAhPT0gYXJyQltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgeyBzaGFsbG93RXF1YWxBcnJheXMsIHNoYWxsb3dFcXVhbE9iamVjdHMgfTtcbiIsImltcG9ydCB1c2VNZWRpYVF1ZXJ5IGZyb20gJy4vdXNlTWVkaWFRdWVyeSc7XG5pbXBvcnQgeyBSZWFjdE5vZGUsIFJlYWN0RWxlbWVudCwgRkMsIENTU1Byb3BlcnRpZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBNZWRpYVF1ZXJ5QWxsUXVlcnlhYmxlLCBNZWRpYVF1ZXJ5TWF0Y2hlcnMgfSBmcm9tICcuL3R5cGVzJztcblxuaW50ZXJmYWNlIE1lZGlhUXVlcnlQcm9wcyBleHRlbmRzIE1lZGlhUXVlcnlBbGxRdWVyeWFibGUge1xuICBjb21wb25lbnQ/OiBSZWFjdE5vZGVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGUgfCAoKG1hdGNoZXM6IGJvb2xlYW4pID0+IFJlYWN0Tm9kZSk7XG4gIHF1ZXJ5Pzogc3RyaW5nO1xuICBzdHlsZT86IENTU1Byb3BlcnRpZXM7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgZGV2aWNlPzogTWVkaWFRdWVyeU1hdGNoZXJzO1xuICB2YWx1ZXM/OiBQYXJ0aWFsPE1lZGlhUXVlcnlNYXRjaGVycz47XG4gIG9uQmVmb3JlQ2hhbmdlPzogKF9tYXRjaGVzOiBib29sZWFuKSA9PiB2b2lkO1xuICBvbkNoYW5nZT86IChfbWF0Y2hlczogYm9vbGVhbikgPT4gdm9pZDtcbn1cblxuLy8gUmVhY3ROb2RlIGFuZCBSZWFjdEVsZW1lbnQgdHlwaW5ncyBhcmUgYSBsaXR0bGUgZnVua3kgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cywgc28gdGhlIFJlYWN0RWxlbWVudCBjYXN0IGlzIG5lZWRlZCBvbiB0aGUgcmV0dXJuXG5jb25zdCBNZWRpYVF1ZXJ5OiBGQzxNZWRpYVF1ZXJ5UHJvcHM+ID0gKHtcbiAgY2hpbGRyZW4sXG4gIGRldmljZSxcbiAgb25DaGFuZ2UsXG4gIC4uLnNldHRpbmdzXG59KSA9PiB7XG4gIGNvbnN0IG1hdGNoZXMgPSB1c2VNZWRpYVF1ZXJ5KHNldHRpbmdzLCBkZXZpY2UsIG9uQ2hhbmdlKTtcblxuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuKG1hdGNoZXMpIGFzIFJlYWN0RWxlbWVudDtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcyA/IGNoaWxkcmVuIGFzIFJlYWN0RWxlbWVudCA6IG51bGw7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBNZWRpYVF1ZXJ5O1xuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgTWVkaWFRdWVyeUFsbFF1ZXJ5YWJsZSB9IGZyb20gJy4vdHlwZXMnXG5cbmNvbnN0IENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFBhcnRpYWw8TWVkaWFRdWVyeUFsbFF1ZXJ5YWJsZT4gfCB1bmRlZmluZWQ+KHVuZGVmaW5lZClcblxuZXhwb3J0IGRlZmF1bHQgQ29udGV4dFxuIiwiaW1wb3J0IHVzZU1lZGlhUXVlcnkgZnJvbSAnLi91c2VNZWRpYVF1ZXJ5J1xuaW1wb3J0IE1lZGlhUXVlcnkgZnJvbSAnLi9Db21wb25lbnQnXG5pbXBvcnQgdG9RdWVyeSBmcm9tICcuL3RvUXVlcnknXG5pbXBvcnQgQ29udGV4dCBmcm9tICcuL0NvbnRleHQnXG5cbmV4cG9ydCB7XG4gIE1lZGlhUXVlcnkgYXMgZGVmYXVsdCxcbiAgdXNlTWVkaWFRdWVyeSxcbiAgdG9RdWVyeSxcbiAgQ29udGV4dFxufVxuXG5leHBvcnQgdHlwZSB7XG4gIE1lZGlhUXVlcnlUeXBlcyxcbiAgTWVkaWFRdWVyeVR5cGUsXG4gIE1lZGlhUXVlcnlGZWF0dXJlcyxcbiAgTWVkaWFRdWVyeU1hdGNoZXJzLFxuICBNZWRpYVF1ZXJ5QWxsUXVlcnlhYmxlXG59IGZyb20gJy4vdHlwZXMnXG4iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5cbmNvbnN0IHN0cmluZ09yTnVtYmVyID0gUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gIFByb3BUeXBlcy5zdHJpbmcsXG4gIFByb3BUeXBlcy5udW1iZXJcbl0pXG5cbi8vIG1lZGlhIHR5cGVzXG5jb25zdCB0eXBlcyA9IHtcbiAgYWxsOiBQcm9wVHlwZXMuYm9vbCxcbiAgZ3JpZDogUHJvcFR5cGVzLmJvb2wsXG4gIGF1cmFsOiBQcm9wVHlwZXMuYm9vbCxcbiAgYnJhaWxsZTogUHJvcFR5cGVzLmJvb2wsXG4gIGhhbmRoZWxkOiBQcm9wVHlwZXMuYm9vbCxcbiAgcHJpbnQ6IFByb3BUeXBlcy5ib29sLFxuICBwcm9qZWN0aW9uOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2NyZWVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgdHR5OiBQcm9wVHlwZXMuYm9vbCxcbiAgdHY6IFByb3BUeXBlcy5ib29sLFxuICBlbWJvc3NlZDogUHJvcFR5cGVzLmJvb2xcbn1cblxuLy8gcHJvcGVydGllcyB0aGF0IG1hdGNoIG1lZGlhIHF1ZXJpZXNcbmNvbnN0IG1hdGNoZXJzID0ge1xuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAncG9ydHJhaXQnLFxuICAgICdsYW5kc2NhcGUnXG4gIF0pLFxuXG4gIHNjYW46IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ3Byb2dyZXNzaXZlJyxcbiAgICAnaW50ZXJsYWNlJ1xuICBdKSxcblxuICBhc3BlY3RSYXRpbzogUHJvcFR5cGVzLnN0cmluZyxcbiAgZGV2aWNlQXNwZWN0UmF0aW86IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgaGVpZ2h0OiBzdHJpbmdPck51bWJlcixcbiAgZGV2aWNlSGVpZ2h0OiBzdHJpbmdPck51bWJlcixcblxuICB3aWR0aDogc3RyaW5nT3JOdW1iZXIsXG4gIGRldmljZVdpZHRoOiBzdHJpbmdPck51bWJlcixcblxuICBjb2xvcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgY29sb3JJbmRleDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgbW9ub2Nocm9tZTogUHJvcFR5cGVzLmJvb2wsXG4gIHJlc29sdXRpb246IHN0cmluZ09yTnVtYmVyLFxuICB0eXBlOiBPYmplY3Qua2V5cyh0eXBlcylcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuY29uc3QgeyB0eXBlLCAuLi5mZWF0dXJlTWF0Y2hlcnMgfSA9IG1hdGNoZXJzXG5cbi8vIG1lZGlhIGZlYXR1cmVzXG5jb25zdCBmZWF0dXJlcyA9IHtcbiAgbWluQXNwZWN0UmF0aW86IFByb3BUeXBlcy5zdHJpbmcsXG4gIG1heEFzcGVjdFJhdGlvOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBtaW5EZXZpY2VBc3BlY3RSYXRpbzogUHJvcFR5cGVzLnN0cmluZyxcbiAgbWF4RGV2aWNlQXNwZWN0UmF0aW86IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgbWluSGVpZ2h0OiBzdHJpbmdPck51bWJlcixcbiAgbWF4SGVpZ2h0OiBzdHJpbmdPck51bWJlcixcbiAgbWluRGV2aWNlSGVpZ2h0OiBzdHJpbmdPck51bWJlcixcbiAgbWF4RGV2aWNlSGVpZ2h0OiBzdHJpbmdPck51bWJlcixcblxuICBtaW5XaWR0aDogc3RyaW5nT3JOdW1iZXIsXG4gIG1heFdpZHRoOiBzdHJpbmdPck51bWJlcixcbiAgbWluRGV2aWNlV2lkdGg6IHN0cmluZ09yTnVtYmVyLFxuICBtYXhEZXZpY2VXaWR0aDogc3RyaW5nT3JOdW1iZXIsXG5cbiAgbWluQ29sb3I6IFByb3BUeXBlcy5udW1iZXIsXG4gIG1heENvbG9yOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIG1pbkNvbG9ySW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gIG1heENvbG9ySW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgbWluTW9ub2Nocm9tZTogUHJvcFR5cGVzLm51bWJlcixcbiAgbWF4TW9ub2Nocm9tZTogUHJvcFR5cGVzLm51bWJlcixcblxuICBtaW5SZXNvbHV0aW9uOiBzdHJpbmdPck51bWJlcixcbiAgbWF4UmVzb2x1dGlvbjogc3RyaW5nT3JOdW1iZXIsXG5cbiAgLi4uZmVhdHVyZU1hdGNoZXJzXG59XG5cbmNvbnN0IGFsbCA9IHsgLi4udHlwZXMsIC4uLmZlYXR1cmVzIH1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBhbGw6IGFsbCxcbiAgdHlwZXM6IHR5cGVzLFxuICBtYXRjaGVyczogbWF0Y2hlcnMsXG4gIGZlYXR1cmVzOiBmZWF0dXJlc1xufVxuIiwiaW1wb3J0IGh5cGhlbmF0ZSBmcm9tICdoeXBoZW5hdGUtc3R5bGUtbmFtZSdcbmltcG9ydCBtcSBmcm9tICcuL21lZGlhUXVlcnknXG5pbXBvcnQgeyBNZWRpYVF1ZXJ5QWxsUXVlcnlhYmxlIH0gZnJvbSAnLi90eXBlcydcblxuY29uc3QgbmVnYXRlID0gKGNvbmQ6IHN0cmluZykgPT4gYG5vdCAke2NvbmR9YFxuXG5jb25zdCBrZXlWYWwgPSAoazogc3RyaW5nLCB2OiB1bmtub3duKTogc3RyaW5nID0+IHtcbiAgY29uc3QgcmVhbEtleSA9IGh5cGhlbmF0ZShrKVxuXG4gIC8vIHB4IHNob3J0aGFuZFxuICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgdiA9IGAke3Z9cHhgXG4gIH1cbiAgaWYgKHYgPT09IHRydWUpIHtcbiAgICByZXR1cm4gcmVhbEtleVxuICB9XG4gIGlmICh2ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBuZWdhdGUocmVhbEtleSlcbiAgfVxuICByZXR1cm4gYCgke3JlYWxLZXl9OiAke3Z9KWBcbn1cblxuY29uc3Qgam9pbiA9IChjb25kczogc3RyaW5nW10pOiBzdHJpbmcgPT4gY29uZHMuam9pbignIGFuZCAnKVxuXG5jb25zdCB0b1F1ZXJ5ID0gKG9iajogUGFydGlhbDxNZWRpYVF1ZXJ5QWxsUXVlcnlhYmxlPik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHJ1bGVzOiBzdHJpbmdbXSA9IFtdXG4gIE9iamVjdC5rZXlzKG1xLmFsbCkuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IHYgPSBvYmpbayBhcyBrZXlvZiBNZWRpYVF1ZXJ5QWxsUXVlcnlhYmxlXVxuICAgIGlmICh2ICE9IG51bGwpIHtcbiAgICAgIHJ1bGVzLnB1c2goa2V5VmFsKGssIHYpKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGpvaW4ocnVsZXMpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvUXVlcnlcbiIsImltcG9ydCB7IHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IG1hdGNoTWVkaWEgZnJvbSAnbWF0Y2htZWRpYXF1ZXJ5J1xuaW1wb3J0IGh5cGhlbmF0ZSBmcm9tICdoeXBoZW5hdGUtc3R5bGUtbmFtZSdcbmltcG9ydCB7IHNoYWxsb3dFcXVhbE9iamVjdHMgfSBmcm9tICdzaGFsbG93LWVxdWFsJ1xuaW1wb3J0IHRvUXVlcnkgZnJvbSAnLi90b1F1ZXJ5J1xuaW1wb3J0IENvbnRleHQgZnJvbSAnLi9Db250ZXh0J1xuaW1wb3J0IHsgTWVkaWFRdWVyeUFsbFF1ZXJ5YWJsZSwgTWVkaWFRdWVyeU1hdGNoZXJzIH0gZnJvbSAnLi90eXBlcydcblxudHlwZSBNZWRpYVF1ZXJ5U2V0dGluZ3MgPSBQYXJ0aWFsPE1lZGlhUXVlcnlBbGxRdWVyeWFibGUgJiB7IHF1ZXJ5Pzogc3RyaW5nIH0+XG50eXBlIEh5cGhlbmF0ZUtleVR5cGVzID0gTWVkaWFRdWVyeU1hdGNoZXJzIHwgTWVkaWFRdWVyeUFsbFF1ZXJ5YWJsZTtcblxuY29uc3QgbWFrZVF1ZXJ5ID0gKHNldHRpbmdzOiBNZWRpYVF1ZXJ5U2V0dGluZ3MpID0+IHNldHRpbmdzLnF1ZXJ5IHx8IHRvUXVlcnkoc2V0dGluZ3MpXG5cbmNvbnN0IGh5cGhlbmF0ZUtleXMgPSAob2JqPzogSHlwaGVuYXRlS2V5VHlwZXMpICA9PiB7XG4gIHR5cGUgSyA9IGtleW9mIEh5cGhlbmF0ZUtleVR5cGVzO1xuXG4gIGlmICghb2JqKSByZXR1cm4gdW5kZWZpbmVkXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopIGFzIEtbXVxuXG4gIHJldHVybiBrZXlzLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICByZXN1bHRbaHlwaGVuYXRlKGtleSldID0gb2JqW2tleV1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIHR5cGVvZiBvYmpbS10+KVxufVxuXG5jb25zdCB1c2VJc1VwZGF0ZSA9ICgpID0+IHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKGZhbHNlKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB0cnVlXG4gIH0sIFtdKVxuXG4gIHJldHVybiByZWYuY3VycmVudFxufVxuXG5jb25zdCB1c2VEZXZpY2UgPSAoZGV2aWNlRnJvbVByb3BzPzogTWVkaWFRdWVyeU1hdGNoZXJzKTogUGFydGlhbDxNZWRpYVF1ZXJ5QWxsUXVlcnlhYmxlPiB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IGRldmljZUZyb21Db250ZXh0ID0gdXNlQ29udGV4dChDb250ZXh0KVxuICBjb25zdCBnZXREZXZpY2UgPSAoKSA9PlxuICAgIGh5cGhlbmF0ZUtleXMoZGV2aWNlRnJvbVByb3BzKSB8fCBoeXBoZW5hdGVLZXlzKGRldmljZUZyb21Db250ZXh0KVxuICBjb25zdCBbIGRldmljZSwgc2V0RGV2aWNlIF0gPSB1c2VTdGF0ZShnZXREZXZpY2UpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBuZXdEZXZpY2UgPSBnZXREZXZpY2UoKVxuICAgIGlmICghc2hhbGxvd0VxdWFsT2JqZWN0cyhkZXZpY2UsIG5ld0RldmljZSkpIHtcbiAgICAgIHNldERldmljZShuZXdEZXZpY2UpXG4gICAgfVxuICB9LCBbIGRldmljZUZyb21Qcm9wcywgZGV2aWNlRnJvbUNvbnRleHQgXSlcblxuICByZXR1cm4gZGV2aWNlXG59XG5cbmNvbnN0IHVzZVF1ZXJ5ID0gKHNldHRpbmdzOiBNZWRpYVF1ZXJ5U2V0dGluZ3MpID0+IHtcbiAgY29uc3QgZ2V0UXVlcnkgPSAoKSA9PiBtYWtlUXVlcnkoc2V0dGluZ3MpXG4gIGNvbnN0IFsgcXVlcnksIHNldFF1ZXJ5IF0gPSB1c2VTdGF0ZShnZXRRdWVyeSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG5ld1F1ZXJ5ID0gZ2V0UXVlcnkoKVxuICAgIGlmIChxdWVyeSAhPT0gbmV3UXVlcnkpIHtcbiAgICAgIHNldFF1ZXJ5KG5ld1F1ZXJ5KVxuICAgIH1cbiAgfSwgWyBzZXR0aW5ncyBdKVxuXG4gIHJldHVybiBxdWVyeVxufVxuXG5jb25zdCB1c2VNYXRjaE1lZGlhID0gKHF1ZXJ5OiBzdHJpbmcsIGRldmljZT86IE1lZGlhUXVlcnlNYXRjaGVycykgPT4ge1xuICBjb25zdCBnZXRNYXRjaE1lZGlhID0gKCkgPT4gbWF0Y2hNZWRpYShxdWVyeSwgZGV2aWNlIHx8IHt9LCAhIWRldmljZSlcbiAgY29uc3QgWyBtcSwgc2V0TXEgXSA9IHVzZVN0YXRlKGdldE1hdGNoTWVkaWEpXG4gIGNvbnN0IGlzVXBkYXRlID0gdXNlSXNVcGRhdGUoKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzVXBkYXRlKSB7XG4gICAgICAvLyBza2lwIG9uIG1vdW50aW5nLCBpdCBoYXMgYWxyZWFkeSBiZWVuIHNldFxuICAgICAgY29uc3QgbmV3TXEgPSBnZXRNYXRjaE1lZGlhKClcbiAgICAgIHNldE1xKG5ld01xKVxuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAobmV3TXEpIHtcbiAgICAgICAgICBuZXdNcS5kaXNwb3NlKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgWyBxdWVyeSwgZGV2aWNlIF0pXG5cbiAgcmV0dXJuIG1xXG59XG5cbmNvbnN0IHVzZU1hdGNoZXMgPSAobWVkaWFRdWVyeTogTWVkaWFRdWVyeUxpc3QpOiBib29sZWFuID0+IHtcbiAgY29uc3QgWyBtYXRjaGVzLCBzZXRNYXRjaGVzIF0gPSB1c2VTdGF0ZTxib29sZWFuPihtZWRpYVF1ZXJ5Lm1hdGNoZXMpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVNYXRjaGVzID0gKGV2OiBNZWRpYVF1ZXJ5TGlzdEV2ZW50KSA9PiB7XG4gICAgICBzZXRNYXRjaGVzKGV2Lm1hdGNoZXMpXG4gICAgfVxuICAgIG1lZGlhUXVlcnkuYWRkTGlzdGVuZXIodXBkYXRlTWF0Y2hlcylcbiAgICBzZXRNYXRjaGVzKG1lZGlhUXVlcnkubWF0Y2hlcylcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtZWRpYVF1ZXJ5LnJlbW92ZUxpc3RlbmVyKHVwZGF0ZU1hdGNoZXMpXG4gICAgfVxuICB9LCBbIG1lZGlhUXVlcnkgXSlcblxuICByZXR1cm4gbWF0Y2hlc1xufVxuXG5jb25zdCB1c2VNZWRpYVF1ZXJ5ID0gKHNldHRpbmdzOiBNZWRpYVF1ZXJ5U2V0dGluZ3MsIGRldmljZT86IE1lZGlhUXVlcnlNYXRjaGVycywgb25DaGFuZ2U/OiAoXzogYm9vbGVhbikgPT4gdm9pZCkgPT4ge1xuICBjb25zdCBkZXZpY2VTZXR0aW5ncyA9IHVzZURldmljZShkZXZpY2UpXG4gIGNvbnN0IHF1ZXJ5ID0gdXNlUXVlcnkoc2V0dGluZ3MpXG4gIGlmICghcXVlcnkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvciBtaXNzaW5nIE1lZGlhUXVlcnkhJylcbiAgY29uc3QgbXEgPSB1c2VNYXRjaE1lZGlhKHF1ZXJ5LCBkZXZpY2VTZXR0aW5ncylcbiAgY29uc3QgbWF0Y2hlcyA9IHVzZU1hdGNoZXMobXEgYXMgdW5rbm93biBhcyBNZWRpYVF1ZXJ5TGlzdClcbiAgY29uc3QgaXNVcGRhdGUgPSB1c2VJc1VwZGF0ZSgpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNVcGRhdGUgJiYgb25DaGFuZ2UpIHtcbiAgICAgIG9uQ2hhbmdlKG1hdGNoZXMpXG4gICAgfVxuICB9LCBbIG1hdGNoZXMgXSlcblxuICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4ge1xuICAgIGlmIChtcSkge1xuICAgICAgbXEuZGlzcG9zZSgpXG4gICAgfVxuICB9LCBbXSlcblxuICByZXR1cm4gbWF0Y2hlc1xufVxuXG5leHBvcnQgZGVmYXVsdCB1c2VNZWRpYVF1ZXJ5XG4iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfcmVhY3RfXzsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsbnVsbCwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaW5kZXgudHNcIik7XG4iXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9fIiwibWF0Y2giLCJtYXRjaFF1ZXJ5IiwicGFyc2UiLCJwYXJzZVF1ZXJ5IiwiUkVfTUVESUFfUVVFUlkiLCJSRV9NUV9FWFBSRVNTSU9OIiwiUkVfTVFfRkVBVFVSRSIsIlJFX0xFTkdUSF9VTklUIiwiUkVfUkVTT0xVVElPTl9VTklUIiwibWVkaWFRdWVyeSIsInZhbHVlcyIsInNvbWUiLCJxdWVyeSIsImludmVyc2UiLCJ0eXBlTWF0Y2giLCJ0eXBlIiwiZXhwcmVzc2lvbnNNYXRjaCIsImV4cHJlc3Npb25zIiwiZXZlcnkiLCJleHByZXNzaW9uIiwiZmVhdHVyZSIsIm1vZGlmaWVyIiwiZXhwVmFsdWUiLCJ2YWx1ZSIsInRvTG93ZXJDYXNlIiwidG9QeCIsInRvRHBpIiwidG9EZWNpbWFsIiwicGFyc2VJbnQiLCJzcGxpdCIsIm1hcCIsInRyaW0iLCJjYXB0dXJlcyIsInBhcnNlZCIsInJhdGlvIiwiZGVjaW1hbCIsIk51bWJlciIsIm51bWJlcnMiLCJyZXNvbHV0aW9uIiwicGFyc2VGbG9hdCIsInVuaXRzIiwiU3RyaW5nIiwibGVuZ3RoIiwidXBwZXJjYXNlUGF0dGVybiIsIm1zUGF0dGVybiIsImNhY2hlIiwidG9IeXBoZW5Mb3dlciIsImh5cGhlbmF0ZVN0eWxlTmFtZSIsIm5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsImhOYW1lIiwicmVwbGFjZSIsInRlc3QiLCJfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyIsInN0YXRpY01hdGNoIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsImR5bmFtaWNNYXRjaCIsIndpbmRvdyIsIm1hdGNoTWVkaWEiLCJNcWwiLCJmb3JjZVN0YXRpYyIsInNlbGYiLCJtcWwiLCJjYWxsIiwibWF0Y2hlcyIsIm1lZGlhIiwiYWRkTGlzdGVuZXIiLCJ1cGRhdGUiLCJyZW1vdmVMaXN0ZW5lciIsImRpc3Bvc2UiLCJsaXN0ZW5lciIsImV2dCIsImdldE93blByb3BlcnR5U3ltYm9scyIsIk9iamVjdCIsInByb3RvdHlwZSIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0IiwidmFsIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwic2hvdWxkVXNlTmF0aXZlIiwiYXNzaWduIiwidGVzdDEiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGVzdDIiLCJpIiwiZnJvbUNoYXJDb2RlIiwib3JkZXIyIiwibiIsImpvaW4iLCJ0ZXN0MyIsImZvckVhY2giLCJsZXR0ZXIiLCJrZXlzIiwiZXJyIiwidGFyZ2V0Iiwic291cmNlIiwiZnJvbSIsInRvIiwic3ltYm9scyIsInMiLCJhcmd1bWVudHMiLCJrZXkiLCJwcmludFdhcm5pbmciLCJSZWFjdFByb3BUeXBlc1NlY3JldCIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsImhhcyIsInRleHQiLCJtZXNzYWdlIiwiY29uc29sZSIsImVycm9yIiwiRXJyb3IiLCJ4IiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJnZXRTdGFjayIsInR5cGVTcGVjTmFtZSIsImV4Iiwic3RhY2siLCJyZXNldFdhcm5pbmdDYWNoZSIsIlJlYWN0SXMiLCJlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsIiwiaXNWYWxpZEVsZW1lbnQiLCJ0aHJvd09uRGlyZWN0QWNjZXNzIiwiSVRFUkFUT1JfU1lNQk9MIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsIkFOT05ZTU9VUyIsIlJlYWN0UHJvcFR5cGVzIiwiYXJyYXkiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsImJpZ2ludCIsImJvb2wiLCJmdW5jIiwibnVtYmVyIiwib2JqZWN0Iiwic3RyaW5nIiwic3ltYm9sIiwiYW55IiwiY3JlYXRlQW55VHlwZUNoZWNrZXIiLCJhcnJheU9mIiwiY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyIiwiZWxlbWVudCIsImNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlciIsImVsZW1lbnRUeXBlIiwiY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlciIsImluc3RhbmNlT2YiLCJjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyIiwibm9kZSIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwib25lT2YiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJvbmVPZlR5cGUiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwic2hhcGUiLCJjcmVhdGVTaGFwZVR5cGVDaGVja2VyIiwiZXhhY3QiLCJjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyIiwiaXMiLCJ5IiwiUHJvcFR5cGVFcnJvciIsImRhdGEiLCJjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlciIsInZhbGlkYXRlIiwibWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUiLCJtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCIsImNoZWNrVHlwZSIsImlzUmVxdWlyZWQiLCJwcm9wcyIsInByb3BOYW1lIiwicHJvcEZ1bGxOYW1lIiwic2VjcmV0IiwiY2FjaGVLZXkiLCJjaGFpbmVkQ2hlY2tUeXBlIiwiYmluZCIsImV4cGVjdGVkVHlwZSIsInByb3BWYWx1ZSIsInByb3BUeXBlIiwiZ2V0UHJvcFR5cGUiLCJwcmVjaXNlVHlwZSIsImdldFByZWNpc2VUeXBlIiwidHlwZUNoZWNrZXIiLCJBcnJheSIsImlzQXJyYXkiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJleHBlY3RlZENsYXNzIiwiZXhwZWN0ZWRDbGFzc05hbWUiLCJhY3R1YWxDbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJleHBlY3RlZFZhbHVlcyIsInZhbHVlc1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXBsYWNlciIsImFycmF5T2ZUeXBlQ2hlY2tlcnMiLCJjaGVja2VyIiwiZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nIiwiZXhwZWN0ZWRUeXBlcyIsImNoZWNrZXJSZXN1bHQiLCJwdXNoIiwiZXhwZWN0ZWRUeXBlc01lc3NhZ2UiLCJpc05vZGUiLCJpbnZhbGlkVmFsaWRhdG9yRXJyb3IiLCJzaGFwZVR5cGVzIiwiYWxsS2V5cyIsInN0ZXAiLCJlbnRyaWVzIiwibmV4dCIsImRvbmUiLCJlbnRyeSIsImlzU3ltYm9sIiwiUmVnRXhwIiwiRGF0ZSIsImNvbnN0cnVjdG9yIiwiUHJvcFR5cGVzIiwiaXNFbGVtZW50IiwiRnVuY3Rpb24iLCJoYXNTeW1ib2wiLCJmb3IiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9BU1lOQ19NT0RFX1RZUEUiLCJSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfQkxPQ0tfVFlQRSIsIlJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUiLCJSRUFDVF9SRVNQT05ERVJfVFlQRSIsIlJFQUNUX1NDT1BFX1RZUEUiLCIkJHR5cGVvZiIsInR5cGVPZiIsIiQkdHlwZW9mVHlwZSIsIkFzeW5jTW9kZSIsIkNvbmN1cnJlbnRNb2RlIiwiQ29udGV4dENvbnN1bWVyIiwiQ29udGV4dFByb3ZpZGVyIiwiRWxlbWVudCIsIkZvcndhcmRSZWYiLCJGcmFnbWVudCIsIkxhenkiLCJNZW1vIiwiUG9ydGFsIiwiUHJvZmlsZXIiLCJTdHJpY3RNb2RlIiwiU3VzcGVuc2UiLCJoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSIsImlzQXN5bmNNb2RlIiwiaXNDb25jdXJyZW50TW9kZSIsImlzQ29udGV4dENvbnN1bWVyIiwiaXNDb250ZXh0UHJvdmlkZXIiLCJpc0ZvcndhcmRSZWYiLCJpc0ZyYWdtZW50IiwiaXNMYXp5IiwiaXNNZW1vIiwiaXNQb3J0YWwiLCJpc1Byb2ZpbGVyIiwiaXNTdHJpY3RNb2RlIiwiaXNTdXNwZW5zZSIsInNoYWxsb3dFcXVhbE9iamVjdHMiLCJvYmpBIiwib2JqQiIsImFLZXlzIiwiYktleXMiLCJsZW4iLCJzaGFsbG93RXF1YWxBcnJheXMiLCJhcnJBIiwiYXJyQiIsInVzZU1lZGlhUXVlcnlfMSIsIl9faW1wb3J0RGVmYXVsdCIsIk1lZGlhUXVlcnkiLCJfYSIsImNoaWxkcmVuIiwiZGV2aWNlIiwib25DaGFuZ2UiLCJzZXR0aW5ncyIsIl9fcmVzdCIsImRlZmF1bHQiLCJyZWFjdF8xIiwiQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VNZWRpYVF1ZXJ5IiwiQ29tcG9uZW50XzEiLCJ0b1F1ZXJ5XzEiLCJ0b1F1ZXJ5IiwiQ29udGV4dF8xIiwicHJvcF90eXBlc18xIiwic3RyaW5nT3JOdW1iZXIiLCJ0eXBlcyIsImFsbCIsImdyaWQiLCJhdXJhbCIsImJyYWlsbGUiLCJoYW5kaGVsZCIsInByaW50IiwicHJvamVjdGlvbiIsInNjcmVlbiIsInR0eSIsInR2IiwiZW1ib3NzZWQiLCJtYXRjaGVycyIsIm9yaWVudGF0aW9uIiwic2NhbiIsImFzcGVjdFJhdGlvIiwiZGV2aWNlQXNwZWN0UmF0aW8iLCJoZWlnaHQiLCJkZXZpY2VIZWlnaHQiLCJ3aWR0aCIsImRldmljZVdpZHRoIiwiY29sb3IiLCJjb2xvckluZGV4IiwibW9ub2Nocm9tZSIsImZlYXR1cmVNYXRjaGVycyIsImZlYXR1cmVzIiwiX19hc3NpZ24iLCJtaW5Bc3BlY3RSYXRpbyIsIm1heEFzcGVjdFJhdGlvIiwibWluRGV2aWNlQXNwZWN0UmF0aW8iLCJtYXhEZXZpY2VBc3BlY3RSYXRpbyIsIm1pbkhlaWdodCIsIm1heEhlaWdodCIsIm1pbkRldmljZUhlaWdodCIsIm1heERldmljZUhlaWdodCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJtaW5EZXZpY2VXaWR0aCIsIm1heERldmljZVdpZHRoIiwibWluQ29sb3IiLCJtYXhDb2xvciIsIm1pbkNvbG9ySW5kZXgiLCJtYXhDb2xvckluZGV4IiwibWluTW9ub2Nocm9tZSIsIm1heE1vbm9jaHJvbWUiLCJtaW5SZXNvbHV0aW9uIiwibWF4UmVzb2x1dGlvbiIsImh5cGhlbmF0ZV9zdHlsZV9uYW1lXzEiLCJtZWRpYVF1ZXJ5XzEiLCJuZWdhdGUiLCJjb25kIiwiY29uY2F0Iiwia2V5VmFsIiwiayIsInYiLCJyZWFsS2V5IiwiY29uZHMiLCJvYmoiLCJydWxlcyIsIm1hdGNobWVkaWFxdWVyeV8xIiwic2hhbGxvd19lcXVhbF8xIiwibWFrZVF1ZXJ5IiwiaHlwaGVuYXRlS2V5cyIsInJlZHVjZSIsInJlc3VsdCIsInVzZUlzVXBkYXRlIiwicmVmIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiY3VycmVudCIsInVzZURldmljZSIsImRldmljZUZyb21Qcm9wcyIsImRldmljZUZyb21Db250ZXh0IiwidXNlQ29udGV4dCIsImdldERldmljZSIsInVzZVN0YXRlIiwic2V0RGV2aWNlIiwibmV3RGV2aWNlIiwidXNlUXVlcnkiLCJnZXRRdWVyeSIsInNldFF1ZXJ5IiwibmV3UXVlcnkiLCJ1c2VNYXRjaE1lZGlhIiwiZ2V0TWF0Y2hNZWRpYSIsIm1xIiwic2V0TXEiLCJpc1VwZGF0ZSIsIm5ld01xXzEiLCJ1c2VNYXRjaGVzIiwic2V0TWF0Y2hlcyIsInVwZGF0ZU1hdGNoZXMiLCJldiIsImRldmljZVNldHRpbmdzIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiZCIsImRlZmluaXRpb24iLCJvIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwicHJvcCIsInIiLCJ0b1N0cmluZ1RhZyIsIl9fd2VicGFja19leHBvcnRzX18iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-responsive/dist/react-responsive.js\n");

/***/ })

};
;